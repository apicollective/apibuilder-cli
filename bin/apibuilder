#!/usr/bin/env ruby

# CLI to API Builder
#
# Usage:
#  apibuilder <command> <arguments>
#  PROFILE=localhost apibuilder <command> <arguments>
#  APIBUILDER_TOKEN=xxx apibuilder <command> <arguments>
#
# Environment variables:
#    PROFILE: will default to the 'default' specified in your configuration file
#    APIBUILDER_TOKEN: If specified, we will use this token to connect to apibuilder
#
# The arguments vary by the command
#
# apibuilder list organizations
#  - Returns a list of all of the organizations that you have access to
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    LIMIT=10 OFFSET=0 apibuilder list organizations
#
# apibuilder list applications apicollective
#  - Returns a list of the applications for the organization apicollective
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    HAS_VERSION=t LIMIT=10 OFFSET=0 apibuilder list applications apicollective
#
# apibuilder list versions apicollective apibuilder-api
#  - Returns a list of all of the versions for the specific org and application.
#  - Pagination is implemented with environment variables LIMIT and OFFSET. Example:
#    LIMIT=10 OFFSET=0 apibuilder list applications apicollective
#
# apibuilder code apicollective apibuilder-api latest scala_models /tmp
#  - Returns the code for apicollective/apibuilder version 'latest' using the
#    codegenerator 'scala_models', writing the generated code to the directory
#    /tmp
#
# apibuilder download apicollective apibuilder-api latest original|service
#  - Downloads the 'original' uploaded file used to create the specified
#    version of the application. This example would download
#    http://apibuilder.me/apicollective/apibuilder-api/latest/original and print to stdout
#
# apibuilder example apicollective apibuilder-api latest type
#  - Generates an example JSON document for the specified type
#
# apibuilder upload apicollective apibuilder-api api/api.json [--version 1.5.0-dev] [--force] [--silent]
#  - Uploads the file api/api.json to the apicollective org, apibuilder application.
#    The uploaded file will be the specified version, defaulting to
#    the output from git describe.
#
# apibuilder update [--path path]
#  - Reads a config file, optionally specified by path
#    parameter. Invokes the apibuilder code generators specified in the
#    configuration file.
#
# apibuilder clean apicollective apibuilder-api [--branch branch-name] [--silent] [--legacy]
#  - Interactively deletes from ApiBuilder any version not tagged in the source repo.
#  - Using the --silent flag will delete versions without asking.
#
# apibuilder cli version
#  - Displays the current version of the CLI
#
# apibuilder cli version latest
#  - Displays the latest available version of the CLI
#
# apibuilder cli upgrade
#  - Upgrade the CLI to the latest version
#

load File.join(File.dirname(__FILE__), '../src/apibuilder-cli.rb')

env = {
  :profile => ApibuilderCli::Util.read_non_empty_string(ENV['PROFILE']),
  :apibuilder_token => ApibuilderCli::Util.read_non_empty_string(ENV['APIBUILDER_TOKEN']) || ApibuilderCli::Util.read_non_empty_string(ENV['APIDOC_TOKEN']),
  :limit => ApibuilderCli::Util.read_non_empty_integer(ENV['LIMIT']),
  :offset => ApibuilderCli::Util.read_non_empty_integer(ENV['OFFSET']),
  :has_version => ApibuilderCli::Util.read_non_empty_string(ENV['HAS_VERSION'])
}

client = ApibuilderCli::Config.client_from_profile(:profile => env[:profile], :token => env[:apibuilder_token])

command = ARGV.shift.to_s.strip

def all_commands
  commands = []
  IO.readlines(__FILE__).each do |l|
    if md = l.strip.gsub(/\s+/, ' ').sub(/^elsif/, 'if').match(/if command == \"(\w+)\"/)
      commands << md[1]
    end
  end
  commands
end

# Returns true if the two files are different - this is a diff that
# excludes changes made only to lines with apibuilder version header
# comments.
def different?(source, target)
  if source.strip == target.strip
    false
  elsif strip_apibuilder_comments(source).strip == strip_apibuilder_comments(target).strip
    false
  else
    true
  end
end

def file_is_scaffolding?(file)
  !file.flags.nil? && file.flags.include?(Io::Apibuilder::Generator::V0::Models::FileFlag.scaffolding)
end

# Searches backwards through the commit history to look for the last commit
# that corresponds to an api version that was uploaded to ApiBuilder. Looks
# backwards a max of 100 commits.
def head_of_latest_uploaded_version(org, application, client)
  found = nil
  0.upto(99).each do |i|
    version = ApibuilderCli::Git.generate_version(i)
    begin
      apibuilder_version = client.versions.get_by_application_key_and_version(org, application, version)
      found = i
      break
    rescue Io::Apibuilder::Api::V0::HttpClient::ServerError => e
      # Continue looking when the version is not found; fail for other exceptions.
      if e.code != 404
        raise e
      end
    end
  end
  found
end

# Apibuilder injects a few comments into the code base to identify
# versions; we want to exclude those lines for the purposes of seeing
# if the API has changed as there is no functional change if only
# these comments have changed. This method strips those values from
# the provided string.
def strip_apibuilder_comments(value)
  lines = value.strip.split("\n").map do |l|
    stripped = l.strip
    if stripped.match(/^[\*|\#]\s+service version: .+$/i)
      ""
    elsif stripped.match(/^[\*|\#]\s+apibuilder:/)
      ""
    elsif stripped.match(/^val UserAgent = /)
      ""
    elsif stripped.match(/^val Version = /)
      ""
    elsif stripped.match(/^USER_AGENT = 'apibuilder:/)
      ""
    elsif stripped.match(/^VERSION = '/)
      ""
    else
      l
    end
  end
  lines.join("\n").strip
end

def write_files(files, directory)
  files.each do |file|
    if file.dir
      target_dir = File.join(directory, file.dir)
      `mkdir -p #{target_dir}`
    else
      target_dir = directory
    end
    target_file = File.join(target_dir, file.name)
    puts " - %s" % target_file
    File.open(target_file, "w") do |out|
      out << file.contents
    end
  end
end

def filter_files(requested_files, downloaded_files, generator)
  requested_files.collect do |filename|
    file_regex = Regexp::new("^" + filename.gsub('.', '\.').gsub('*', '[^.]*').gsub('?', '[^.]?') + "$")
    files = downloaded_files.select { |f| !file_regex.match(f.name).nil? }
    if files.empty?
      $stderr.puts "  WARNING: Could not find file/pattern #{filename} for generator[#{generator}]. Available filenames: #{downloaded_files.map(&:name).join(", ")}"
    end
    files
  end.flatten|[]
end

def handle_server_error(e)
  $stderr.puts ""
  if e.is_a?(Io::Apibuilder::Api::V0::HttpClient::ServerError)
    if e.code == 401
      $stderr.puts "ERROR: 401 Unauthorized"
      $stderr.puts "  URI: #{e.uri}"
      $stderr.puts ""

    elsif e.code == 404
      $stderr.puts "ERROR: 404 Not Found"
      $stderr.puts "  URI: #{e.uri}"
      $stderr.puts ""

    elsif e.code == 409
      $stderr.puts "ERROR 409: Unprocessable Entity"
      JSON.parse(e.body).each do |error|
        if error['code'] == "validation_error"
          $stderr.puts " - %s" % error['message']
        else
          $stderr.puts " - %s: %s" % [error['code'], error['message']]
        end
      end
    else
      $stderr.puts "ERROR #{e.code}: Server Error"
      raise e
    end
  else
    $stderr.puts "#{e.to_s}"
  end
end

def upload_version(client, org, application, version, data, path = "")
  original_form = Io::Apibuilder::Api::V0::Models::OriginalForm.new(:data => data)
  form = Io::Apibuilder::Api::V0::Models::VersionForm.new(:original_form => original_form)

  print "Uploading #{path == '' ? 'data' : path} to #{client.url}/#{org}/#{application}/#{version} ... "
  begin
    client.versions.put_by_application_key_and_version(org, application, version, form)
    puts "success"
  rescue Exception => e
    handle_server_error(e)
  rescue Exception => e
    puts ""
    puts "** ERROR: #{e}"
    exit(1)
  end
end

if command == "list"
  resource = ARGV.shift.to_s.strip

  if resource == "organizations"
    client.organizations.get(:limit => env[:limit], :offset => env[:offset]).each do |org|
      puts org.key
    end

  elsif resource == "applications"
    org = ARGV.shift.to_s.strip

    if org.empty?
      puts "organization is required"
      exit(1)
    else
      client.applications.get(org,
                              :limit => env[:limit],
                              :offset => env[:offset],
                              :has_version => Io::Apibuilder::Api::V0::HttpClient::Helper.to_boolean('has_version', env[:has_version])
                             ).each do |app|
        puts app.key
      end
    end

  elsif resource == "versions"
    org = ARGV.shift.to_s.strip
    application = ARGV.shift.to_s.strip

    if org.empty? || application.empty?
      puts "organization and application are required"
      exit(1)
    else
      client.versions.get_by_application_key(org, application, :limit => env[:limit], :offset => env[:offset]).each do |v|
        puts v.version
      end
    end

  elsif resource.empty?
    puts "resource to list is required"
    exit(1)

  else
    puts "unrecognized resource[#{resource}]"
    exit(1)
  end

elsif command == "download"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  version = ARGV.shift.to_s.strip
  typ = ARGV.shift.to_s.strip

  if org.empty? || application.empty? || version.empty? || typ.empty?
    puts "org, application, version, and type are required"
    exit(1)
  end

  begin
    app = client.versions.get_by_application_key_and_version(org, application, version)
    if typ == "original"
      puts app.original.data
    elsif typ == "service"
      puts app.service.to_json
    else
      $stderr.puts "  ERROR: invalid type[#{typ}] - must be 'original' or 'service'"
    end
  rescue Exception => e
    handle_server_error(e)
  end
  
elsif command == "example"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  version = ARGV.shift.to_s.strip
  typ = ARGV.shift.to_s.strip
  optional_fields = ARGV.shift.to_s.strip

  if org.empty? || application.empty? || version.empty? || typ.empty?
    puts "org, application, version, and type are required"
    exit(1)
  end

  if optional_fields.empty?
    optional_fields = false
  else
    optional_fields = Io::Apibuilder::Spec::V0::HttpClient::Helper.to_boolean("optional_fields", optional_fields)
  end

  begin
    example = client.versions.get_example_by_application_key_and_version_and_type_name(org, application, version, typ, :optional_fields => optional_fields)
    puts example
  rescue Exception => e
    handle_server_error(e)
  end
  
elsif command == "code"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  version = ARGV.shift.to_s.strip
  generator = ARGV.shift.to_s.strip
  directory = ARGV.shift.to_s.strip
  filenames = ARGV.collect { |f| f.to_s.strip }

  if org.empty? || application.empty? || version.empty? || generator.empty? || directory.empty?
    puts "org, application, version, generator, and directory are required"
    exit(1)
  end

  if !File.directory?(directory)
    puts "ERROR: directory '%s' does not exist" % directory
    exit(1)
  end

  begin
    code = client.code.get(org, application, version, generator).files
    if filenames.empty?
      write_files(code, directory)
    else
      write_files(filter_files(filenames, code, generator), directory)
    end
  rescue Exception => e
    handle_server_error(e)
  end

elsif command == "upload"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip
  path = ARGV.shift.to_s.strip

  args = ApibuilderCli::Args.parse(ARGV)
  force = args.key?(:force)
  silent = args.key?(:silent)
  version = args[:version].to_s.strip

  if org.empty? || application.empty? || path.empty?
    puts "org, application, path are required"
    exit(1)
  end

  if !File.exists?(path)
    puts "File[#{path}] does not exist"
    exit(1)
  end

  if version.empty?
    head = head_of_latest_uploaded_version(org, application, client)
    if !head.nil? && system("git diff --exit-code --quiet HEAD~#{head} HEAD #{path}") && !force
      # Don't bother uploading a new version if there is no diff between the last version and
      # the current commit. Allow uploading if --force is used.
      puts "No diff from last tag on file [#{path}]. Please either specify a --version or use the --force flag."
    else
      default_version = ApibuilderCli::Git.generate_version

      if silent
        # Don't prompt for a version when in --silent mode.
        version = default_version
        if version == ""
          puts "WARNING: No version generated; #{path} will not be uploaded to ApiBuilder until there is at least one tagged version."
        else
          puts "Generated version [#{version}]"
        end
      else
        print "Version"
        if default_version != ""
          print " [#{default_version}]"
        end
        print ": "

        version = nil
        while version.nil?
          answer = $stdin.gets
          if answer.strip.empty? && default_version != ""
            version = default_version
          else
            version = answer.strip
          end
        end
      end
    end
  end

  unless version.empty?
    upload_version(client, org, application, version, IO.read(path), path)
  end

elsif command == "update"
  args = ApibuilderCli::Args.parse(ARGV)
  path = File.expand_path(args[:path] || ApibuilderCli::AppConfig.default_path)

  if !File.exists?(path)
    puts "File #{path} does not exit"
    exit(1)
  end

  updates = []
  puts "Fetching code from #{client.url}"

  app_config = ApibuilderCli::AppConfig.new(:path => path)

  tracked_files = ApibuilderCli::FileTracker.new(app_config.project_dir)

  app_config.code.projects.map do |project|
    project.generators.each do |generator|
      generator.targets.each do |target|
        puts "  #{project.org}/#{project.name}/#{project.version}/#{generator.name}..."
        base_target_path = File.join(app_config.project_dir, target)
        reference_target_path = File.join(app_config.project_dir, ApibuilderCli::Config::APIBUILDER_LOCAL_DIR, target)

        begin
          code = client.code.get(project.org, project.name, project.version, generator.name).files
          if generator.files.nil?
            files = code
          else
            files = filter_files(generator.files, code, generator.name)
          end
          files.each do |f|
            # For scaffolding (i.e. locally-editable) files, store a copy of the original in the .apibuilder directory in order to
            # demonstrate diffs to be manually ported to the scaffolding files.
            [[f, base_target_path], file_is_scaffolding?(f) ? [Io::Apibuilder::Generator::V0::Models::File.new(f.to_hash.merge(:flags => nil)), reference_target_path] : nil].compact.each do |file, file_target_path|
              final_target_path = app_config.settings.code_create_directories ? File.join(file_target_path, file.dir) : file_target_path

              # check if target path ends with the filename - if not, this is a directory target and need to check if dir exists
              # for example: "play_2_x_routes: api/conf/routes" is a file
              # while "anorm_2_x_parsers: api/app/generated" should be a directory we check if exists
              FileUtils.mkdir_p(final_target_path) unless final_target_path.include?(file.name) || Dir.exists?(final_target_path) || File.exists?(final_target_path)

              target_path = File.directory?(final_target_path) ? File.join(final_target_path, file.name) : final_target_path
              existing_source = File.exists?(target_path) ? IO.read(target_path).strip : ""

              print "    " + target_path.sub(/^#{app_config.project_dir}\/?/, '') + ": "
              if file_is_scaffolding?(file)
                if existing_source == ""
                  puts "new scaffolding file"
                  updates << { :source => file.contents, :generator => generator.name, :target => target_path }
                else
                  puts "scaffolding file - ignoring"
                end
              else
                if different?(file.contents, existing_source)
                  puts "changed"
                  updates << { :source => file.contents, :generator => generator.name, :target => target_path }
                else
                  puts "unchanged"
                end
                tracked_files.track!(project.org, project.name, generator.name, target_path)
              end
            end
          end
        rescue Exception => e
          handle_server_error(e)
        end
        puts ""
      end
    end
  end

  puts ""
  if !updates.empty?
    puts "Copying updated code"
    updates.each do |data|
      puts " - #{data[:generator]} => #{data[:target]}"
      ApibuilderCli::Util.write_to_file(data[:target], data[:source])
    end
    if app_config.settings.code_cleanup_generated_files
      puts "Cleaning up obsolete code"
      tracked_files.to_cleanup.each do |file|
        file_dir = File.join(File.split(file).shift)
        cmd = "rm #{file}; rmdir -p #{file_dir} > /dev/null 2>&1"
        puts "** #{cmd}"
        `#{cmd}`
      end
    end
  end
  tracked_files.save!

elsif command == "clean"
  org = ARGV.shift.to_s.strip
  application = ARGV.shift.to_s.strip

  args = ApibuilderCli::Args.parse(ARGV)
  branch = args[:branch].to_s.strip.downcase
  branch = "master" if branch.empty?
  legacy = args.key?(:legacy)
  silent = args.key?(:silent)
  limit = 50

  if org.empty? || application.empty?
    puts "org, application are required"
    exit(1)
  end

  if legacy && silent
    puts "--legacy is intended to be interactive; please use either --legacy or --silent but not both."
    exit(1)
  end

  # This is a brute-force implementation. We could consider doing fancier things (such as
  # only cleaning back to the most recent tag and providing a flag to clean "all"), but
  # for simplicity and reduced bugs, let's use the naive implementation until it proves
  # burdensome.
  offset = 0
  versions = []
  # Must load all versions up front, since deleting will disrupt the clean pagination.
  loop do
    current_page = client.versions.get_by_application_key(org, application, :limit => limit, :offset => offset).each do |v|
      versions << v.version
    end
    offset += 1
    break if current_page.size < limit
  end

  ApibuilderCli::Git.in_branch(branch) do
    to_delete = versions - ApibuilderCli::Git.tag_list.map { |tag|
      branch == "master" ? tag : "#{tag}#{ApibuilderCli::Git.branch_suffix(branch)}"
    }
    if branch == "master"
      to_delete.reject! { |version|
        # Ignore versions with a branch delimiter.
        version.match(/-b[0-9a-f]{7}-.+$/)
      }
    else
      to_delete.select! { |version|
        # Only consider versions that match the branch.
        version.end_with?(ApibuilderCli::Git.branch_suffix(branch))
      }
    end
    if to_delete.size == 0
      puts "API is clean"
    else
      to_delete.each do |version|
        delete = false
        move_to_branch = ""
        if silent
          delete = true
        elsif legacy
          print "Move #{version} to branch? Enter branch name or leave blank to delete: "
          answer = $stdin.gets
          if answer.strip.empty?
            delete = true
          else
            move_to_branch = answer.strip
          end
        else
          print "Delete #{version} [Yn]? "
          answer = $stdin.gets
          delete = answer.strip.empty? || answer.strip.downcase == "y"
        end
        if delete
          client.versions.delete_by_application_key_and_version(org, application, version)
          puts "deleted #{version}..."
        elsif move_to_branch != ""
          app = client.versions.get_by_application_key_and_version(org, application, version)
          new_version = "#{version}#{ApibuilderCli::Git.branch_suffix(move_to_branch)}"
          upload_version(client, org, application, new_version, app.original.data)
          client.versions.delete_by_application_key_and_version(org, application, version)
          puts "deleted #{version}..."
        else
          puts "skipping #{version}..."
        end
      end
    end
  end

elsif command == "cli"
  subcommand = ARGV.shift.to_s.strip

  if subcommand == "version"
    puts ApibuilderCli::Version.current

  elsif subcommand == "latest"
    puts ApibuilderCli::Version.latest

  elsif subcommand == "upgrade"
    current = ApibuilderCli::Version.current
    latest = ApibuilderCli::Version.latest
    if current == latest
      puts "you already have the latest version[#{current}] installed"
    else
      ["git fetch", "git checkout #{latest}"].each do |cmd|
        puts cmd
        `#{cmd}`
      end

      puts "apibuilder-cli upgraded to latest version"
    end

  else
    puts "cli subcommand is required"
    exit(1)
  end

elsif command.empty?
  puts "** ERROR: Missing command is required. Available commands:"
  all_commands.sort.each do |cmd|
    puts " - %s" % cmd
  end
  exit(1)

else
  puts "** ERROR: unrecognized command[#{command}].  Available commands:"
  all_commands.sort.each do |cmd|
    puts " - %s" % cmd
  end
  exit(1)
end

