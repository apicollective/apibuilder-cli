# Generated by API Builder - https://www.apibuilder.io
# Service version: 0.12.89
# apibuilder:0.12.87 https://app.apibuilder.io/apicollective/apibuilder-api/0.12.89/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'date'
require 'rubygems'
require 'json'
require 'bigdecimal'

# Host API documentation for applications providing REST APIs, facilitating the
# design of good resource first APIs.
module Io
  module Apibuilder
    module Api
      module V0

        class Client

          module Constants

            BASE_URL = 'https://api.apibuilder.io' unless defined?(Constants::BASE_URL)
            NAMESPACE = 'io.apibuilder.api.v0' unless defined?(Constants::NAMESPACE)
            USER_AGENT = 'apibuilder:0.12.87 https://app.apibuilder.io/apicollective/apibuilder-api/0.12.89/ruby_client' unless defined?(Constants::USER_AGENT)
            VERSION = '0.12.89' unless defined?(Constants::VERSION)
            VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

          end

          attr_reader :url

          def initialize(url, opts={})
            @url = HttpClient::Preconditions.assert_class('url', url, String)
            @base_url = URI(url)
            @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
            @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
            @http_handler = opts.delete(:http_handler) || HttpClient::DefaultHttpHandler.new

            HttpClient::Preconditions.assert_empty_opts(opts)
            HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
          end

          # Creates an instance of the client using the base url specified in the API spec.
          def Client.at_base_url(opts={})
            Client.new(Constants::BASE_URL, opts)
          end

          def request(path=nil)
            HttpClient::Preconditions.assert_class_or_nil('path', path, String)
            request = HttpClient::Request.new(@http_handler, @base_url, path.to_s).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

            @default_headers.each do |key, value|
              request = request.with_header(key, value)
            end

            if @authorization
              request = request.with_auth(@authorization)
            end

            request
          end

          def applications
            @applications ||= ::Io::Apibuilder::Api::V0::Clients::Applications.new(self)
          end

          def attributes
            @attributes ||= ::Io::Apibuilder::Api::V0::Clients::Attributes.new(self)
          end

          def authentications
            @authentications ||= ::Io::Apibuilder::Api::V0::Clients::Authentications.new(self)
          end

          def changes
            @changes ||= ::Io::Apibuilder::Api::V0::Clients::Changes.new(self)
          end

          def code
            @code ||= ::Io::Apibuilder::Api::V0::Clients::Code.new(self)
          end

          def domains
            @domains ||= ::Io::Apibuilder::Api::V0::Clients::Domains.new(self)
          end

          def email_verification_confirmation_forms
            @email_verification_confirmation_forms ||= ::Io::Apibuilder::Api::V0::Clients::EmailVerificationConfirmationForms.new(self)
          end

          def generator_services
            @generator_services ||= ::Io::Apibuilder::Api::V0::Clients::GeneratorServices.new(self)
          end

          def generator_with_services
            @generator_with_services ||= ::Io::Apibuilder::Api::V0::Clients::GeneratorWithServices.new(self)
          end

          def healthchecks
            @healthchecks ||= ::Io::Apibuilder::Api::V0::Clients::Healthchecks.new(self)
          end

          def items
            @items ||= ::Io::Apibuilder::Api::V0::Clients::Items.new(self)
          end

          def memberships
            @memberships ||= ::Io::Apibuilder::Api::V0::Clients::Memberships.new(self)
          end

          def membership_requests
            @membership_requests ||= ::Io::Apibuilder::Api::V0::Clients::MembershipRequests.new(self)
          end

          def organizations
            @organizations ||= ::Io::Apibuilder::Api::V0::Clients::Organizations.new(self)
          end

          def password_resets
            @password_resets ||= ::Io::Apibuilder::Api::V0::Clients::PasswordResets.new(self)
          end

          def password_reset_requests
            @password_reset_requests ||= ::Io::Apibuilder::Api::V0::Clients::PasswordResetRequests.new(self)
          end

          def subscriptions
            @subscriptions ||= ::Io::Apibuilder::Api::V0::Clients::Subscriptions.new(self)
          end

          def tokens
            @tokens ||= ::Io::Apibuilder::Api::V0::Clients::Tokens.new(self)
          end

          def users
            @users ||= ::Io::Apibuilder::Api::V0::Clients::Users.new(self)
          end

          def validations
            @validations ||= ::Io::Apibuilder::Api::V0::Clients::Validations.new(self)
          end

          def versions
            @versions ||= ::Io::Apibuilder::Api::V0::Clients::Versions.new(self)
          end

          def watches
            @watches ||= ::Io::Apibuilder::Api::V0::Clients::Watches.new(self)
          end
        end

        module Clients

          class Applications

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Returns the versions assocoated with the specified application. The latest
            # version is the first result returned.
            def get_metadata_and_versions_by_application_key(org_key, application_key, incoming={})
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(org_key)}/metadata/#{CGI.escape(application_key)}/versions").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::ApplicationMetadataVersion.new(x) }
            end

            # Returns the latest version number as a string
            def get_metadata_and_versions_and_latest_txt_by_application_key(org_key, application_key)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              r = @client.request("/#{CGI.escape(org_key)}/metadata/#{CGI.escape(application_key)}/versions/latest.txt").get
              r
            end

            # Search all applications. Results are always paginated.
            def get(org_key, incoming={})
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                :has_version => (x = opts.delete(:has_version); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_version', x)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(org_key)}").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Application.new(x) }
            end

            # Create an application.
            def post(org_key, application_form)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              (x = application_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::ApplicationForm) ? x : ::Io::Apibuilder::Api::V0::Models::ApplicationForm.new(x))
              r = @client.request("/#{CGI.escape(org_key)}").with_json(application_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Application.new(r)
            end

            # Updates an application.
            def put_by_application_key(org_key, application_key, application_form)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              (x = application_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::ApplicationForm) ? x : ::Io::Apibuilder::Api::V0::Models::ApplicationForm.new(x))
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").with_json(application_form.to_json).put
              ::Io::Apibuilder::Api::V0::Models::Application.new(r)
            end

            # Deletes a specific application and its associated versions.
            def delete_by_application_key(org_key, application_key)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").delete
              nil
            end

            # Moves application to a new organization.
            def post_move_by_application_key(org_key, application_key, move_form)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              (x = move_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::MoveForm) ? x : ::Io::Apibuilder::Api::V0::Models::MoveForm.new(x))
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/move").with_json(move_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Application.new(r)
            end

          end

          class Attributes

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search all attributes. Results are always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/attributes").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Attribute.new(x) }
            end

            # Returns the attribute with this name.
            def get_by_name(name)
              HttpClient::Preconditions.assert_class('name', name, String)
              r = @client.request("/attributes/#{CGI.escape(name)}").get
              ::Io::Apibuilder::Api::V0::Models::Attribute.new(r)
            end

            # Create a new attribute.
            def post(attribute_form)
              (x = attribute_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::AttributeForm) ? x : ::Io::Apibuilder::Api::V0::Models::AttributeForm.new(x))
              r = @client.request("/attributes").with_json(attribute_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Attribute.new(r)
            end

            # Deletes the attribute with this name. Only the user who created an attribute
            # can delete it.
            def delete_by_name(name)
              HttpClient::Preconditions.assert_class('name', name, String)
              r = @client.request("/attributes/#{CGI.escape(name)}").delete
              nil
            end

          end

          class Authentications

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def get_session_by_id(id)
              HttpClient::Preconditions.assert_class('id', id, String)
              r = @client.request("/authentications/session/#{CGI.escape(id)}").get
              ::Io::Apibuilder::Api::V0::Models::Authentication.new(r)
            end

          end

          class Changes

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                :application_key => (x = opts.delete(:application_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('application_key', x, String)),
                :from => (x = opts.delete(:from); x.nil? ? nil : HttpClient::Preconditions.assert_class('from', x, String)),
                :to => (x = opts.delete(:to); x.nil? ? nil : HttpClient::Preconditions.assert_class('to', x, String)),
                :type => (x = opts.delete(:type); x.nil? ? nil : HttpClient::Preconditions.assert_class('type', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/changes").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Change.new(x) }
            end

          end

          class Code

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Generate code for a specific version of an application.
            def get(org_key, application_key, version, generator_key)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              HttpClient::Preconditions.assert_class('generator_key', generator_key, String)
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}/#{CGI.escape(generator_key)}").get
              ::Io::Apibuilder::Api::V0::Models::Code.new(r)
            end

          end

          class Domains

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Add a domain to this organization
            def post(org_key, domain)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              (x = domain; x.is_a?(::Io::Apibuilder::Api::V0::Models::Domain) ? x : ::Io::Apibuilder::Api::V0::Models::Domain.new(x))
              r = @client.request("/domains/#{CGI.escape(org_key)}").with_json(domain.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Domain.new(r)
            end

            # Remove this domain from this organization
            def delete_by_name(org_key, name)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('name', name, String)
              r = @client.request("/domains/#{CGI.escape(org_key)}/#{CGI.escape(name)}").delete
              nil
            end

          end

          class EmailVerificationConfirmationForms

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Validate an email address using a token.
            def post(email_verification_confirmation_form)
              (x = email_verification_confirmation_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::EmailVerificationConfirmationForm) ? x : ::Io::Apibuilder::Api::V0::Models::EmailVerificationConfirmationForm.new(x))
              r = @client.request("/email_verification_confirmations").with_json(email_verification_confirmation_form.to_json).post
              nil
            end

          end

          class GeneratorServices

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # List all generator services
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :uri => (x = opts.delete(:uri); x.nil? ? nil : HttpClient::Preconditions.assert_class('uri', x, String)),
                :generator_key => (x = opts.delete(:generator_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('generator_key', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 100 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/generator_services").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::GeneratorService.new(x) }
            end

            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/generator_services/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::GeneratorService.new(r)
            end

            def post(generator_service_form)
              (x = generator_service_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::GeneratorServiceForm) ? x : ::Io::Apibuilder::Api::V0::Models::GeneratorServiceForm.new(x))
              r = @client.request("/generator_services").with_json(generator_service_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::GeneratorService.new(r)
            end

            # Deletes a generator service.
            def delete_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/generator_services/#{guid}").delete
              nil
            end

          end

          class GeneratorWithServices

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # List all available generators
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :service_guid => (x = opts.delete(:service_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('service_guid', HttpClient::Helper.to_uuid(x), String)),
                :service_uri => (x = opts.delete(:service_uri); x.nil? ? nil : HttpClient::Preconditions.assert_class('service_uri', x, String)),
                :attribute_name => (x = opts.delete(:attribute_name); x.nil? ? nil : HttpClient::Preconditions.assert_class('attribute_name', x, String)),
                :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 100 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/generators").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::GeneratorWithService.new(x) }
            end

            def get_by_key(key)
              HttpClient::Preconditions.assert_class('key', key, String)
              r = @client.request("/generators/#{CGI.escape(key)}").get
              ::Io::Apibuilder::Api::V0::Models::GeneratorWithService.new(r)
            end

          end

          class Healthchecks

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def get_healthcheck
              r = @client.request("/_internal_/healthcheck").get
              ::Io::Apibuilder::Generator::V0::Models::Healthcheck.new(r)
            end

            def get_migrate
              r = @client.request("/_internal_/migrate").get
              r.inject({}) { |hash, x| hash[x[0]] = x[1].nil? ? nil : x[1]; hash }
            end

          end

          class Items

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/items").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Item.new(x) }
            end

            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/items/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::Item.new(r)
            end

          end

          class Memberships

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search all memberships. Results are always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :org_guid => (x = opts.delete(:org_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_guid', HttpClient::Helper.to_uuid(x), String)),
                :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/memberships").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Membership.new(x) }
            end

            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/memberships/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::Membership.new(r)
            end

            def delete_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/memberships/#{guid}").delete
              nil
            end

          end

          class MembershipRequests

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search all membership requests. Results are always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :org_guid => (x = opts.delete(:org_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_guid', HttpClient::Helper.to_uuid(x), String)),
                :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/membership_requests").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::MembershipRequest.new(x) }
            end

            # Create a membership request
            def post
              r = @client.request("/membership_requests").post
              ::Io::Apibuilder::Api::V0::Models::MembershipRequest.new(r)
            end

            # Accepts this membership request. User will become a member of the specified
            # organization.
            def post_accept_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/membership_requests/#{guid}/accept").post
              nil
            end

            # Declines this membership request. User will NOT become a member of the
            # specified organization.
            def post_decline_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/membership_requests/#{guid}/decline").post
              nil
            end

          end

          class Organizations

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search all organizations. Results are always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                :namespace => (x = opts.delete(:namespace); x.nil? ? nil : HttpClient::Preconditions.assert_class('namespace', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/organizations").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Organization.new(x) }
            end

            # Returns the organization with this key.
            def get_by_key(key)
              HttpClient::Preconditions.assert_class('key', key, String)
              r = @client.request("/organizations/#{CGI.escape(key)}").get
              ::Io::Apibuilder::Api::V0::Models::Organization.new(r)
            end

            # Create a new organization.
            def post(organization_form)
              (x = organization_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::OrganizationForm) ? x : ::Io::Apibuilder::Api::V0::Models::OrganizationForm.new(x))
              r = @client.request("/organizations").with_json(organization_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Organization.new(r)
            end

            # Update an organization.
            def put_by_key(key, organization_form)
              HttpClient::Preconditions.assert_class('key', key, String)
              (x = organization_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::OrganizationForm) ? x : ::Io::Apibuilder::Api::V0::Models::OrganizationForm.new(x))
              r = @client.request("/organizations/#{CGI.escape(key)}").with_json(organization_form.to_json).put
              ::Io::Apibuilder::Api::V0::Models::Organization.new(r)
            end

            # Deletes an organization and all of its associated applications.
            def delete_by_key(key)
              HttpClient::Preconditions.assert_class('key', key, String)
              r = @client.request("/organizations/#{CGI.escape(key)}").delete
              nil
            end

            # Returns all attribute values for this organization. Results are always
            # paginated.
            def get_attributes_by_key(key, incoming={})
              HttpClient::Preconditions.assert_class('key', key, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/organizations/#{CGI.escape(key)}/attributes").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::AttributeValue.new(x) }
            end

            # Returns the attribute value with this name.
            def get_attributes_by_key_and_name(key, name)
              HttpClient::Preconditions.assert_class('key', key, String)
              HttpClient::Preconditions.assert_class('name', name, String)
              r = @client.request("/organizations/#{CGI.escape(key)}/attributes/#{CGI.escape(name)}").get
              ::Io::Apibuilder::Api::V0::Models::AttributeValue.new(r)
            end

            # Create or update a new attribute value.
            def put_attributes_by_key_and_name(key, name, attribute_value_form)
              HttpClient::Preconditions.assert_class('key', key, String)
              HttpClient::Preconditions.assert_class('name', name, String)
              (x = attribute_value_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::AttributeValueForm) ? x : ::Io::Apibuilder::Api::V0::Models::AttributeValueForm.new(x))
              r = @client.request("/organizations/#{CGI.escape(key)}/attributes/#{CGI.escape(name)}").with_json(attribute_value_form.to_json).put
              ::Io::Apibuilder::Api::V0::Models::AttributeValue.new(r)
            end

            # Deletes the attribute value with the specified name. Only the user who
            # created an attribute value can delete it.
            def delete_attributes_by_key_and_name(key, name)
              HttpClient::Preconditions.assert_class('key', key, String)
              HttpClient::Preconditions.assert_class('name', name, String)
              r = @client.request("/organizations/#{CGI.escape(key)}/attributes/#{CGI.escape(name)}").delete
              nil
            end

          end

          class PasswordResets

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Change the password for this token. If the token is invalid, has been used,
            # or otherwise no longer can be applied, errors will be returned as 409s. A
            # 204 represents that the user has successfully changed their password.
            def post(password_reset)
              (x = password_reset; x.is_a?(::Io::Apibuilder::Api::V0::Models::PasswordReset) ? x : ::Io::Apibuilder::Api::V0::Models::PasswordReset.new(x))
              r = @client.request("/password_resets").with_json(password_reset.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Authentication.new(r)
            end

          end

          class PasswordResetRequests

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Create a new password reset. This will send the user an email with a link to
            # reset their password.
            def post(password_reset_request)
              (x = password_reset_request; x.is_a?(::Io::Apibuilder::Api::V0::Models::PasswordResetRequest) ? x : ::Io::Apibuilder::Api::V0::Models::PasswordResetRequest.new(x))
              r = @client.request("/password_reset_requests").with_json(password_reset_request.to_json).post
              nil
            end

          end

          class Subscriptions

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search subscriptions. Always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :organization_key => (x = opts.delete(:organization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_key', x, String)),
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :publication => (x = opts.delete(:publication); x.nil? ? nil : (x = x; x.is_a?(::Io::Apibuilder::Api::V0::Models::Publication) ? x : ::Io::Apibuilder::Api::V0::Models::Publication.apply(x)).value),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/subscriptions").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Subscription.new(x) }
            end

            # Returns information about a specific subscription.
            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/subscriptions/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::Subscription.new(r)
            end

            # Create a new subscription.
            def post(subscription_form)
              (x = subscription_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::SubscriptionForm) ? x : ::Io::Apibuilder::Api::V0::Models::SubscriptionForm.new(x))
              r = @client.request("/subscriptions").with_json(subscription_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Subscription.new(r)
            end

            def delete_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/subscriptions/#{guid}").delete
              nil
            end

          end

          class Tokens

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def get_users_by_user_guid(user_guid, incoming={})
              HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(user_guid), String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/tokens/users/#{user_guid}").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Token.new(x) }
            end

            # Used to fetch the clear text token.
            def get_cleartext_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/tokens/#{guid}/cleartext").get
              ::Io::Apibuilder::Api::V0::Models::CleartextToken.new(r)
            end

            # Create a new API token for this user
            def post(token_form)
              (x = token_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::TokenForm) ? x : ::Io::Apibuilder::Api::V0::Models::TokenForm.new(x))
              r = @client.request("/tokens").with_json(token_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Token.new(r)
            end

            def delete_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/tokens/#{guid}").delete
              nil
            end

          end

          class Users

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search for a specific user. You must specify at least 1 parameter - either a
            # guid, email or token - and will receive back either 0 or 1 users.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
                :nickname => (x = opts.delete(:nickname); x.nil? ? nil : HttpClient::Preconditions.assert_class('nickname', x, String)),
                :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String))
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/users").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::User.new(x) }
            end

            # Returns information about the user with this guid.
            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/users/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::User.new(r)
            end

            # Used to authenticate a user with an email address and password. Successful
            # authentication returns an instance of the user model. Failed authorizations
            # of any kind are returned as a generic error with code
            # user_authorization_failed.
            def post_authenticate
              r = @client.request("/users/authenticate").post
              ::Io::Apibuilder::Api::V0::Models::Authentication.new(r)
            end

            # Used to authenticate a user using a github access token. This is equivalent
            # to running the following command to get the user info: curl -H
            # 'Authorization: Bearer code' https://api.github.com/user
            def post_authenticate_github
              r = @client.request("/users/authenticate_github").post
              ::Io::Apibuilder::Api::V0::Models::Authentication.new(r)
            end

            # Create a new user.
            def post(user_form)
              (x = user_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::UserForm) ? x : ::Io::Apibuilder::Api::V0::Models::UserForm.new(x))
              r = @client.request("/users").with_json(user_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::User.new(r)
            end

            # Updates information about the user with the specified guid.
            def put_by_guid(guid, user_update_form)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              (x = user_update_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::UserUpdateForm) ? x : ::Io::Apibuilder::Api::V0::Models::UserUpdateForm.new(x))
              r = @client.request("/users/#{guid}").with_json(user_update_form.to_json).put
              ::Io::Apibuilder::Api::V0::Models::User.new(r)
            end

          end

          class Validations

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            def post(value)
              HttpClient::Preconditions.assert_class('value', value, String)
              r = @client.request("/validations").with_body(value).post
              ::Io::Apibuilder::Api::V0::Models::Validation.new(r)
            end

          end

          class Versions

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search all versions of this application. Results are always paginated.
            def get_by_application_key(org_key, application_key, incoming={})
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Version.new(x) }
            end

            # Retrieve a specific version of an application.
            def get_by_application_key_and_version(org_key, application_key, version)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").get
              ::Io::Apibuilder::Api::V0::Models::Version.new(r)
            end

            # Create a new version for an application
            def post_by_version(org_key, version, version_form)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              (x = version_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::VersionForm) ? x : ::Io::Apibuilder::Api::V0::Models::VersionForm.new(x))
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(version)}").with_json(version_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Version.new(r)
            end

            # Upsert a version of an application
            def put_by_application_key_and_version(org_key, application_key, version, version_form)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              (x = version_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::VersionForm) ? x : ::Io::Apibuilder::Api::V0::Models::VersionForm.new(x))
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").with_json(version_form.to_json).put
              ::Io::Apibuilder::Api::V0::Models::Version.new(r)
            end

            # Deletes a specific version.
            def delete_by_application_key_and_version(org_key, application_key, version)
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").delete
              nil
            end

            # Generates an example JSON document of the type with the specified name.
            def get_example_by_application_key_and_version_and_type_name(org_key, application_key, version, type_name, incoming={})
              HttpClient::Preconditions.assert_class('org_key', org_key, String)
              HttpClient::Preconditions.assert_class('application_key', application_key, String)
              HttpClient::Preconditions.assert_class('version', version, String)
              HttpClient::Preconditions.assert_class('type_name', type_name, String)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :optional_fields => (x = opts.delete(:optional_fields); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('optional_fields', x))
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}/example/#{CGI.escape(type_name)}").with_query(query).get
              r
            end

          end

          class Watches

            def initialize(client)
              @client = HttpClient::Preconditions.assert_class('client', client, ::Io::Apibuilder::Api::V0::Client)
            end

            # Search attributes. Always paginated.
            def get(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :organization_key => (x = opts.delete(:organization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_key', x, String)),
                :application_key => (x = opts.delete(:application_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('application_key', x, String)),
                :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/watches").with_query(query).get
              r.map { |x| ::Io::Apibuilder::Api::V0::Models::Watch.new(x) }
            end

            # Returns information about a specific watch.
            def get_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/watches/#{guid}").get
              ::Io::Apibuilder::Api::V0::Models::Watch.new(r)
            end

            # Quick check if a user is watching a specific application.
            def get_check(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              query = {
                :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                :organization_key => HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String),
                :application_key => HttpClient::Preconditions.assert_class('application_key', opts.delete(:application_key), String)
              }.delete_if { |k, v| v.nil? }
              r = @client.request("/watches/check").with_query(query).get
              r
            end

            # Create a new watch.
            def post(watch_form)
              (x = watch_form; x.is_a?(::Io::Apibuilder::Api::V0::Models::WatchForm) ? x : ::Io::Apibuilder::Api::V0::Models::WatchForm.new(x))
              r = @client.request("/watches").with_json(watch_form.to_json).post
              ::Io::Apibuilder::Api::V0::Models::Watch.new(r)
            end

            def delete_by_guid(guid)
              HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(guid), String)
              r = @client.request("/watches/#{guid}").delete
              nil
            end

          end

        end

        module Models

          # Represents a single diff in an application
          class Diff

            module Types
              DIFF_BREAKING = 'diff_breaking' unless defined?(DIFF_BREAKING)
              DIFF_NON_BREAKING = 'diff_non_breaking' unless defined?(DIFF_NON_BREAKING)
            end

            attr_reader :type

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:type], 'Diff')
              @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
            end

            def subtype_to_hash
              raise 'Cannot serialize an instance of diff directly - must use one of the specific types: diff_breaking, diff_non_breaking'
            end

            def to_hash
              subtype_to_hash.merge(:type => @type)
            end

            def Diff.from_json(hash)
              HttpClient::Preconditions.assert_class('hash', hash, Hash)
              discriminator = HttpClient::Helper.symbolize_keys(hash)[:type].to_s.strip
              if discriminator.empty?
                raise "Union type[diff] requires a field named 'type'"
              end
              case discriminator
                when Types::DIFF_BREAKING; DiffBreaking.new(hash)
                when Types::DIFF_NON_BREAKING; DiffNonBreaking.new(hash)
                else DiffUndefinedType.new(:type => discriminator)
              end
            end

          end

          class DiffUndefinedType < Diff

            attr_reader :name

            def initialize(incoming={})
              super(:type => 'undefined_type')
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:type), String)
            end

            def subtype_to_hash
              raise 'Unable to serialize undefined type to json'
            end

            def copy(incoming={})
              raise 'Operation not supported for undefined type'
            end

            def to_hash
              raise 'Operation not supported for undefined type'
            end

          end

          # Identifies the specific type of item that was indexed by search
          class ItemDetail

            module Types
              # Represents that the item indexed was an application
              APPLICATION_SUMMARY = 'application_summary' unless defined?(APPLICATION_SUMMARY)
            end

            attr_reader :type

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:type], 'ItemDetail')
              @type = HttpClient::Preconditions.assert_class('type', opts.delete(:type), String)
            end

            def subtype_to_hash
              raise 'Cannot serialize an instance of item_detail directly - must use one of the specific types: application_summary'
            end

            def to_hash
              subtype_to_hash.merge(:type => @type)
            end

            def ItemDetail.from_json(hash)
              HttpClient::Preconditions.assert_class('hash', hash, Hash)
              discriminator = HttpClient::Helper.symbolize_keys(hash)[:type].to_s.strip
              if discriminator.empty?
                raise "Union type[item_detail] requires a field named 'type'"
              end
              case discriminator
                when Types::APPLICATION_SUMMARY; ApplicationSummary.new(hash)
                else ItemDetailUndefinedType.new(:type => discriminator)
              end
            end

          end

          class ItemDetailUndefinedType < ItemDetail

            attr_reader :name

            def initialize(incoming={})
              super(:type => 'undefined_type')
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:type), String)
            end

            def subtype_to_hash
              raise 'Unable to serialize undefined type to json'
            end

            def copy(incoming={})
              raise 'Operation not supported for undefined type'
            end

            def to_hash
              raise 'Operation not supported for undefined type'
            end

          end

          class OriginalType

            attr_reader :value

            def initialize(value)
              @value = HttpClient::Preconditions.assert_class('value', value, String)
            end

            # Returns the instance of OriginalType for this value, creating a new instance for an unknown value
            def OriginalType.apply(value)
              if value.instance_of?(OriginalType)
                value
              else
                HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                value.nil? ? nil : (from_string(value) || OriginalType.new(value))
              end
            end

            # Returns the instance of OriginalType for this value, or nil if not found
            def OriginalType.from_string(value)
              HttpClient::Preconditions.assert_class('value', value, String)
              OriginalType.ALL.find { |v| v.value == value }
            end

            def OriginalType.ALL
              @@all ||= [OriginalType.api_json, OriginalType.avro_idl, OriginalType.service_json, OriginalType.swagger]
            end

            # The original is in the api.json format
            def OriginalType.api_json
              @@_api_json ||= OriginalType.new('api_json')
            end

            # The original is in Avro Idl format
            def OriginalType.avro_idl
              @@_avro_idl ||= OriginalType.new('avro_idl')
            end

            # This is the canonical service spec for apibuilder itself. See
            # https://www.apibuilder.io/apicollective/apibuilder-spec/latest#model-service
            def OriginalType.service_json
              @@_service_json ||= OriginalType.new('service_json')
            end

            # The original in the Swagger JSON or YAML format
            def OriginalType.swagger
              @@_swagger ||= OriginalType.new('swagger')
            end

            def to_hash
              value
            end

          end

          class Publication

            attr_reader :value

            def initialize(value)
              @value = HttpClient::Preconditions.assert_class('value', value, String)
            end

            # Returns the instance of Publication for this value, creating a new instance for an unknown value
            def Publication.apply(value)
              if value.instance_of?(Publication)
                value
              else
                HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                value.nil? ? nil : (from_string(value) || Publication.new(value))
              end
            end

            # Returns the instance of Publication for this value, or nil if not found
            def Publication.from_string(value)
              HttpClient::Preconditions.assert_class('value', value, String)
              Publication.ALL.find { |v| v.value == value }
            end

            def Publication.ALL
              @@all ||= [Publication.membership_requests_create, Publication.memberships_create, Publication.applications_create, Publication.versions_create]
            end

            # For organizations for which I am an administrator, email me whenever a user
            # applies to join the org.
            def Publication.membership_requests_create
              @@_membership_requests_create ||= Publication.new('membership_requests.create')
            end

            # For organizations for which I am a member, email me whenever a user joins the
            # org.
            def Publication.memberships_create
              @@_memberships_create ||= Publication.new('memberships.create')
            end

            # For organizations for which I am a member, email me whenever an application is
            # created.
            def Publication.applications_create
              @@_applications_create ||= Publication.new('applications.create')
            end

            # For applications that I watch, email me whenever a version is created.
            def Publication.versions_create
              @@_versions_create ||= Publication.new('versions.create')
            end

            def to_hash
              value
            end

          end

          class Visibility

            attr_reader :value

            def initialize(value)
              @value = HttpClient::Preconditions.assert_class('value', value, String)
            end

            # Returns the instance of Visibility for this value, creating a new instance for an unknown value
            def Visibility.apply(value)
              if value.instance_of?(Visibility)
                value
              else
                HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                value.nil? ? nil : (from_string(value) || Visibility.new(value))
              end
            end

            # Returns the instance of Visibility for this value, or nil if not found
            def Visibility.from_string(value)
              HttpClient::Preconditions.assert_class('value', value, String)
              Visibility.ALL.find { |v| v.value == value }
            end

            def Visibility.ALL
              @@all ||= [Visibility.user, Visibility.organization, Visibility.public]
            end

            # Only the creator can view this application
            def Visibility.user
              @@_user ||= Visibility.new('user')
            end

            # Any member of the organization can view this application
            def Visibility.organization
              @@_organization ||= Visibility.new('organization')
            end

            # Anybody, including non logged in users, can view this application
            def Visibility.public
              @@_public ||= Visibility.new('public')
            end

            def to_hash
              value
            end

          end

          # An application has a name and multiple versions of its API.
          class Application

            attr_reader :guid, :organization, :name, :key, :visibility, :description, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :name, :key, :visibility, :audit], 'Application')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Apibuilder::Api::V0::Models::Visibility) ? x : ::Io::Apibuilder::Api::V0::Models::Visibility.apply(x))
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Application.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :organization => organization.to_hash,
                :name => name,
                :key => key,
                :visibility => visibility.value,
                :description => description,
                :audit => audit.to_hash
              }
            end

          end

          class ApplicationForm

            attr_reader :name, :key, :description, :visibility

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:name, :visibility], 'ApplicationForm')
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Apibuilder::Api::V0::Models::Visibility) ? x : ::Io::Apibuilder::Api::V0::Models::Visibility.apply(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ApplicationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :name => name,
                :key => key,
                :description => description,
                :visibility => visibility.value
              }
            end

          end

          class ApplicationMetadata

            attr_reader :guid, :key

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :key], 'ApplicationMetadata')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ApplicationMetadata.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :key => key
              }
            end

          end

          # Describes the versions associated with a given application
          class ApplicationMetadataVersion

            attr_reader :version

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:version], 'ApplicationMetadataVersion')
              @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ApplicationMetadataVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :version => version
              }
            end

          end

          # Summary of an application sufficient for display and links
          class ApplicationSummary < ItemDetail

            attr_reader :guid, :organization, :key

            def initialize(incoming={})
              super(:type => ItemDetail::Types::APPLICATION_SUMMARY)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :key], 'ApplicationSummary')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ApplicationSummary.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :guid => guid,
                :organization => organization.to_hash,
                :key => key
              }
            end

          end

          # Attributes are globally unique key which allow users to specify additional
          # content to pass in to the code generators.
          class Attribute

            attr_reader :guid, :name, :description, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :name, :audit], 'Attribute')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Attribute.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :name => name,
                :description => description,
                :audit => audit.to_hash
              }
            end

          end

          class AttributeForm

            attr_reader :name, :description

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:name], 'AttributeForm')
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              AttributeForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :name => name,
                :description => description
              }
            end

          end

          class AttributeSummary

            attr_reader :guid, :name

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :name], 'AttributeSummary')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              AttributeSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :name => name
              }
            end

          end

          # Attribute values can be set at different levels. Initially we support setting
          # organization wide attributes, but in the future plan to support setting
          # attribute values with each version of the application.
          class AttributeValue

            attr_reader :guid, :attribute, :value, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :attribute, :value, :audit], 'AttributeValue')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @attribute = (x = opts.delete(:attribute); x.is_a?(::Io::Apibuilder::Api::V0::Models::AttributeSummary) ? x : ::Io::Apibuilder::Api::V0::Models::AttributeSummary.new(x))
              @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              AttributeValue.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :attribute => attribute.to_hash,
                :value => value,
                :audit => audit.to_hash
              }
            end

          end

          class AttributeValueForm

            attr_reader :value

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:value], 'AttributeValueForm')
              @value = HttpClient::Preconditions.assert_class('value', opts.delete(:value), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              AttributeValueForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :value => value
              }
            end

          end

          # Represents the result of a successful authorization
          class Authentication

            attr_reader :user, :session

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:user, :session], 'Authentication')
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @session = (x = opts.delete(:session); x.is_a?(::Io::Apibuilder::Api::V0::Models::Session) ? x : ::Io::Apibuilder::Api::V0::Models::Session.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Authentication.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :user => user.to_hash,
                :session => session.to_hash
              }
            end

          end

          # Represents a single change from one version of a service to another
          class Change

            attr_reader :guid, :organization, :application, :from_version, :to_version, :diff, :changed_at, :changed_by, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :application, :from_version, :to_version, :diff, :changed_at, :changed_by, :audit], 'Change')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @application = (x = opts.delete(:application); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @from_version = (x = opts.delete(:from_version); x.is_a?(::Io::Apibuilder::Api::V0::Models::ChangeVersion) ? x : ::Io::Apibuilder::Api::V0::Models::ChangeVersion.new(x))
              @to_version = (x = opts.delete(:to_version); x.is_a?(::Io::Apibuilder::Api::V0::Models::ChangeVersion) ? x : ::Io::Apibuilder::Api::V0::Models::ChangeVersion.new(x))
              @diff = (x = opts.delete(:diff); x.is_a?(::Io::Apibuilder::Api::V0::Models::Diff) ? x : ::Io::Apibuilder::Api::V0::Models::Diff.from_json(x))
              @changed_at = HttpClient::Preconditions.assert_class('changed_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:changed_at)), DateTime)
              @changed_by = (x = opts.delete(:changed_by); x.is_a?(::Io::Apibuilder::Api::V0::Models::UserSummary) ? x : ::Io::Apibuilder::Api::V0::Models::UserSummary.new(x))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Change.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :organization => organization.to_hash,
                :application => application.to_hash,
                :from_version => from_version.to_hash,
                :to_version => to_version.to_hash,
                :diff => diff.to_hash,
                :changed_at => changed_at,
                :changed_by => changed_by.to_hash,
                :audit => audit.to_hash
              }
            end

          end

          # Represents a simpler model of a version specifically for the use case of
          # displaying changes
          class ChangeVersion

            attr_reader :guid, :version

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :version], 'ChangeVersion')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              ChangeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :version => version
              }
            end

          end

          # Separate resource used only for the few actions that require the full token.
          class CleartextToken

            attr_reader :token

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:token], 'CleartextToken')
              @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              CleartextToken.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :token => token
              }
            end

          end

          # Generated source code.
          class Code

            attr_reader :generator, :source, :files

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:generator, :source], 'Code')
              @generator = (x = opts.delete(:generator); x.is_a?(::Io::Apibuilder::Api::V0::Models::GeneratorWithService) ? x : ::Io::Apibuilder::Api::V0::Models::GeneratorWithService.new(x))
              @source = HttpClient::Preconditions.assert_class('source', opts.delete(:source), String)
              @files = HttpClient::Preconditions.assert_class('files', (x = opts.delete(:files); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Apibuilder::Generator::V0::Models::File) ? x : ::Io::Apibuilder::Generator::V0::Models::File.new(x)) }
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Code.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :generator => generator.to_hash,
                :source => source,
                :files => files.map { |o| o.to_hash }
              }
            end

          end

          # Represents a single breaking diff of an application version. A breaking diff
          # indicates that it is possible for an existing client to now experience an
          # error or invalid data due to the diff.
          class DiffBreaking < Diff

            attr_reader :description

            def initialize(incoming={})
              super(:type => Diff::Types::DIFF_BREAKING)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:description], 'DiffBreaking')
              @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              DiffBreaking.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :description => description
              }
            end

          end

          # Represents a single NON breaking diff of an application version.
          class DiffNonBreaking < Diff

            attr_reader :description

            def initialize(incoming={})
              super(:type => Diff::Types::DIFF_NON_BREAKING)
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:description], 'DiffNonBreaking')
              @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              DiffNonBreaking.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def subtype_to_hash
              {
                :description => description
              }
            end

          end

          # Represents a single domain name (e.g. www.apibuilder.io). When a new user
          # registers and confirms their email, we automatically associate that user with
          # a member of the organization associated with their domain. For example, if you
          # confirm your account with an email address of example@somedomain.com, we will
          # automatically create a membership request on your behalf to join the
          # organization with domain somedomain.com.
          class Domain

            attr_reader :name

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:name], 'Domain')
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Domain.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :name => name
              }
            end

          end

          # Data used to confirm an email address. The token is an internal unique
          # identifier used to lookup the specific email address and user account for
          # which we sent an email verification email.
          class EmailVerificationConfirmationForm

            attr_reader :token

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:token], 'EmailVerificationConfirmationForm')
              @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              EmailVerificationConfirmationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :token => token
              }
            end

          end

          class Error

            attr_reader :code, :message

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:code, :message], 'Error')
              @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
              @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :code => code,
                :message => message
              }
            end

          end

          class GeneratorForm

            attr_reader :service_guid, :generator

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:service_guid, :generator], 'GeneratorForm')
              @service_guid = HttpClient::Preconditions.assert_class('service_guid', HttpClient::Helper.to_uuid(opts.delete(:service_guid)), String)
              @generator = (x = opts.delete(:generator); x.is_a?(::Io::Apibuilder::Generator::V0::Models::Generator) ? x : ::Io::Apibuilder::Generator::V0::Models::Generator.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              GeneratorForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :service_guid => service_guid,
                :generator => generator.to_hash
              }
            end

          end

          # Defines a service that provides one or more code generators
          class GeneratorService

            attr_reader :guid, :uri, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :uri, :audit], 'GeneratorService')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @uri = HttpClient::Preconditions.assert_class('uri', opts.delete(:uri), String)
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              GeneratorService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :uri => uri,
                :audit => audit.to_hash
              }
            end

          end

          class GeneratorServiceForm

            attr_reader :uri

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:uri], 'GeneratorServiceForm')
              @uri = HttpClient::Preconditions.assert_class('uri', opts.delete(:uri), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              GeneratorServiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :uri => uri
              }
            end

          end

          # Wraps a service and a generator providing easier access for applications.
          class GeneratorWithService

            attr_reader :service, :generator

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:service, :generator], 'GeneratorWithService')
              @service = (x = opts.delete(:service); x.is_a?(::Io::Apibuilder::Api::V0::Models::GeneratorService) ? x : ::Io::Apibuilder::Api::V0::Models::GeneratorService.new(x))
              @generator = (x = opts.delete(:generator); x.is_a?(::Io::Apibuilder::Generator::V0::Models::Generator) ? x : ::Io::Apibuilder::Generator::V0::Models::Generator.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              GeneratorWithService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :service => service.to_hash,
                :generator => generator.to_hash
              }
            end

          end

          # When searching for content, the results of the search will be a list of items.
          # Each item will have enough information to render for the user, including a
          # type and item_guid to enable creating the appropriate link.
          class Item

            attr_reader :guid, :detail, :label, :description

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :detail, :label], 'Item')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @detail = (x = opts.delete(:detail); x.is_a?(::Io::Apibuilder::Api::V0::Models::ItemDetail) ? x : ::Io::Apibuilder::Api::V0::Models::ItemDetail.from_json(x))
              @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :detail => detail.to_hash,
                :label => label,
                :description => description
              }
            end

          end

          # A membership represents a user in a specific role to an organization.
          # Memberships cannot be created directly. Instead you first create a membership
          # request, then that request is either accepted or declined.
          class Membership

            attr_reader :guid, :user, :organization, :role, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :user, :organization, :role, :audit], 'Membership')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Api::V0::Models::Organization) ? x : ::Io::Apibuilder::Api::V0::Models::Organization.new(x))
              @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :user => user.to_hash,
                :organization => organization.to_hash,
                :role => role,
                :audit => audit.to_hash
              }
            end

          end

          # A membership request represents a user requesting to join an organization with
          # a specific role (e.g. as a member or an admin). Membership requests can be
          # reviewed by any current admin of the organization who can either accept or
          # decline the request.
          class MembershipRequest

            attr_reader :guid, :user, :organization, :role, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :user, :organization, :role, :audit], 'MembershipRequest')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Api::V0::Models::Organization) ? x : ::Io::Apibuilder::Api::V0::Models::Organization.new(x))
              @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              MembershipRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :user => user.to_hash,
                :organization => organization.to_hash,
                :role => role,
                :audit => audit.to_hash
              }
            end

          end

          class MoveForm

            attr_reader :org_key

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:org_key], 'MoveForm')
              @org_key = HttpClient::Preconditions.assert_class('org_key', opts.delete(:org_key), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              MoveForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :org_key => org_key
              }
            end

          end

          # An organization is used to group a set of applications together.
          class Organization

            attr_reader :guid, :key, :name, :namespace, :visibility, :domains, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :key, :name, :namespace, :visibility, :audit], 'Organization')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
              @visibility = (x = opts.delete(:visibility); x.is_a?(::Io::Apibuilder::Api::V0::Models::Visibility) ? x : ::Io::Apibuilder::Api::V0::Models::Visibility.apply(x))
              @domains = HttpClient::Preconditions.assert_class('domains', (x = opts.delete(:domains); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Io::Apibuilder::Api::V0::Models::Domain) ? x : ::Io::Apibuilder::Api::V0::Models::Domain.new(x)) }
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Organization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :key => key,
                :name => name,
                :namespace => namespace,
                :visibility => visibility.value,
                :domains => domains.map { |o| o.to_hash },
                :audit => audit.to_hash
              }
            end

          end

          class OrganizationForm

            attr_reader :name, :key, :namespace, :visibility, :domains

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:name, :namespace], 'OrganizationForm')
              @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
              @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
              @visibility = (x = (x = opts.delete(:visibility); x.nil? ? "organization" : x); x.is_a?(::Io::Apibuilder::Api::V0::Models::Visibility) ? x : ::Io::Apibuilder::Api::V0::Models::Visibility.apply(x))
              @domains = (x = opts.delete(:domains); x.nil? ? nil : HttpClient::Preconditions.assert_class('domains', x, Array).map { |v| HttpClient::Preconditions.assert_class('domains', v, String) })
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :name => name,
                :key => key,
                :namespace => namespace,
                :visibility => visibility.value,
                :domains => domains.nil? ? nil : domains
              }
            end

          end

          # Represents the original input used to create an application version
          class Original

            attr_reader :type, :data

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:type, :data], 'Original')
              @type = (x = opts.delete(:type); x.is_a?(::Io::Apibuilder::Api::V0::Models::OriginalType) ? x : ::Io::Apibuilder::Api::V0::Models::OriginalType.apply(x))
              @data = HttpClient::Preconditions.assert_class('data', opts.delete(:data), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Original.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :type => type.value,
                :data => data
              }
            end

          end

          class OriginalForm

            attr_reader :type, :data

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:data], 'OriginalForm')
              @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Io::Apibuilder::Api::V0::Models::OriginalType) ? x : ::Io::Apibuilder::Api::V0::Models::OriginalType.apply(x)))
              @data = HttpClient::Preconditions.assert_class('data', opts.delete(:data), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              OriginalForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :type => type.nil? ? nil : type.value,
                :data => data
              }
            end

          end

          # Allows a user to change their password with authentication from a token.
          class PasswordReset

            attr_reader :token, :password

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:token, :password], 'PasswordReset')
              @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
              @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              PasswordReset.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :token => token,
                :password => password
              }
            end

          end

          # Create a password reset request - e.g. an email containing a one time URL to
          # change a password
          class PasswordResetRequest

            attr_reader :email

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:email], 'PasswordResetRequest')
              @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              PasswordResetRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :email => email
              }
            end

          end

          # Represents a user sessions (e.g. user logged into site)
          class Session

            attr_reader :id, :expires_at

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:id, :expires_at], 'Session')
              @id = HttpClient::Preconditions.assert_class('id', opts.delete(:id), String)
              @expires_at = HttpClient::Preconditions.assert_class('expires_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:expires_at)), DateTime)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Session.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :id => id,
                :expires_at => expires_at
              }
            end

          end

          # Represents a user that is currently subscribed to a publication
          class Subscription

            attr_reader :guid, :organization, :user, :publication, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :user, :publication, :audit], 'Subscription')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Api::V0::Models::Organization) ? x : ::Io::Apibuilder::Api::V0::Models::Organization.new(x))
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @publication = (x = opts.delete(:publication); x.is_a?(::Io::Apibuilder::Api::V0::Models::Publication) ? x : ::Io::Apibuilder::Api::V0::Models::Publication.apply(x))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Subscription.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :organization => organization.to_hash,
                :user => user.to_hash,
                :publication => publication.value,
                :audit => audit.to_hash
              }
            end

          end

          class SubscriptionForm

            attr_reader :organization_key, :user_guid, :publication

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:organization_key, :user_guid, :publication], 'SubscriptionForm')
              @organization_key = HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String)
              @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
              @publication = (x = opts.delete(:publication); x.is_a?(::Io::Apibuilder::Api::V0::Models::Publication) ? x : ::Io::Apibuilder::Api::V0::Models::Publication.apply(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              SubscriptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :organization_key => organization_key,
                :user_guid => user_guid,
                :publication => publication.value
              }
            end

          end

          # A token gives a user access to the API.
          class Token

            attr_reader :guid, :user, :masked_token, :description, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :user, :masked_token, :audit], 'Token')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @masked_token = HttpClient::Preconditions.assert_class('masked_token', opts.delete(:masked_token), String)
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Token.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :user => user.to_hash,
                :masked_token => masked_token,
                :description => description,
                :audit => audit.to_hash
              }
            end

          end

          class TokenForm

            attr_reader :user_guid, :description

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:user_guid], 'TokenForm')
              @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
              @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              TokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :user_guid => user_guid,
                :description => description
              }
            end

          end

          # A user is a top level person interacting with the api doc server.
          class User

            attr_reader :guid, :email, :nickname, :name, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :email, :nickname, :audit], 'User')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
              @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
              @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              User.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :email => email,
                :nickname => nickname,
                :name => name,
                :audit => audit.to_hash
              }
            end

          end

          class UserForm

            attr_reader :email, :password, :nickname, :name

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:email, :password], 'UserForm')
              @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
              @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
              @nickname = (x = opts.delete(:nickname); x.nil? ? nil : HttpClient::Preconditions.assert_class('nickname', x, String))
              @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :email => email,
                :password => password,
                :nickname => nickname,
                :name => name
              }
            end

          end

          # Summary of a user sufficient for display
          class UserSummary

            attr_reader :guid, :nickname

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :nickname], 'UserSummary')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              UserSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :nickname => nickname
              }
            end

          end

          class UserUpdateForm

            attr_reader :email, :nickname, :name

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:email, :nickname], 'UserUpdateForm')
              @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
              @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
              @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              UserUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :email => email,
                :nickname => nickname,
                :name => name
              }
            end

          end

          # Used only to validate json files - used as a resource where http status code
          # defines success
          class Validation

            attr_reader :valid, :errors

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:valid], 'Validation')
              @valid = HttpClient::Preconditions.assert_boolean('valid', opts.delete(:valid))
              @errors = HttpClient::Preconditions.assert_class('errors', (x = opts.delete(:errors); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('errors', v, String) }
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Validation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :valid => valid,
                :errors => errors
              }
            end

          end

          # Represents a unique version of the application.
          class Version

            attr_reader :guid, :organization, :application, :version, :original, :service, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :organization, :application, :version, :service, :audit], 'Version')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @application = (x = opts.delete(:application); x.is_a?(::Io::Apibuilder::Common::V0::Models::Reference) ? x : ::Io::Apibuilder::Common::V0::Models::Reference.new(x))
              @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
              @original = (x = opts.delete(:original); x.nil? ? nil : (x = x; x.is_a?(::Io::Apibuilder::Api::V0::Models::Original) ? x : ::Io::Apibuilder::Api::V0::Models::Original.new(x)))
              @service = (x = opts.delete(:service); x.is_a?(::Io::Apibuilder::Spec::V0::Models::Service) ? x : ::Io::Apibuilder::Spec::V0::Models::Service.new(x))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :organization => organization.to_hash,
                :application => application.to_hash,
                :version => version,
                :original => original.nil? ? nil : original.to_hash,
                :service => service.to_hash,
                :audit => audit.to_hash
              }
            end

          end

          class VersionForm

            attr_reader :original_form, :visibility

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:original_form], 'VersionForm')
              @original_form = (x = opts.delete(:original_form); x.is_a?(::Io::Apibuilder::Api::V0::Models::OriginalForm) ? x : ::Io::Apibuilder::Api::V0::Models::OriginalForm.new(x))
              @visibility = (x = opts.delete(:visibility); x.nil? ? nil : (x = x; x.is_a?(::Io::Apibuilder::Api::V0::Models::Visibility) ? x : ::Io::Apibuilder::Api::V0::Models::Visibility.apply(x)))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              VersionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :original_form => original_form.to_hash,
                :visibility => visibility.nil? ? nil : visibility.value
              }
            end

          end

          # Users can watch individual applications which enables features like receiving
          # an email notification when there is a new version of an application.
          class Watch

            attr_reader :guid, :user, :organization, :application, :audit

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:guid, :user, :organization, :application, :audit], 'Watch')
              @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              @user = (x = opts.delete(:user); x.is_a?(::Io::Apibuilder::Api::V0::Models::User) ? x : ::Io::Apibuilder::Api::V0::Models::User.new(x))
              @organization = (x = opts.delete(:organization); x.is_a?(::Io::Apibuilder::Api::V0::Models::Organization) ? x : ::Io::Apibuilder::Api::V0::Models::Organization.new(x))
              @application = (x = opts.delete(:application); x.is_a?(::Io::Apibuilder::Api::V0::Models::Application) ? x : ::Io::Apibuilder::Api::V0::Models::Application.new(x))
              @audit = (x = opts.delete(:audit); x.is_a?(::Io::Apibuilder::Common::V0::Models::Audit) ? x : ::Io::Apibuilder::Common::V0::Models::Audit.new(x))
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              Watch.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :guid => guid,
                :user => user.to_hash,
                :organization => organization.to_hash,
                :application => application.to_hash,
                :audit => audit.to_hash
              }
            end

          end

          class WatchForm

            attr_reader :user_guid, :organization_key, :application_key

            def initialize(incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              HttpClient::Preconditions.require_keys(opts, [:user_guid, :organization_key, :application_key], 'WatchForm')
              @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
              @organization_key = HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String)
              @application_key = HttpClient::Preconditions.assert_class('application_key', opts.delete(:application_key), String)
            end

            def to_json
              JSON.dump(to_hash)
            end

            def copy(incoming={})
              WatchForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
            end

            def to_hash
              {
                :user_guid => user_guid,
                :organization_key => organization_key,
                :application_key => application_key
              }
            end

          end

        end

        # ===== END OF SERVICE DEFINITION =====
        module HttpClient

          class HttpHandler

            # Returns a client instance to use
            #
            # @param base_uri The base URI for this API
            # @param path the Requested full http path (including any query strings)
            def instance(base_uri, path)
              raise "Override in subclass"
            end

          end

          class HttpHandlerInstance

            # Executes a request. The provided request object will be an
            # instance of Net::HTTP (e.g. Net::HTTP::Get)
            def execute(request)
              raise "Override in subclass"
            end

          end

          class DefaultHttpHandler < HttpHandler

            def instance(base_uri, path)
              DefaultHttpHandlerInstance.new(base_uri)
            end

          end

          class DefaultHttpHandlerInstance < HttpHandlerInstance

            attr_reader :client

            def initialize(base_uri)
              @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
              @client = Net::HTTP.new(@base_uri.host, @base_uri.port)
              if @base_uri.scheme == "https"
                configure_ssl
              end
            end

            def execute(request)
              response = begin
                           @client.request(request)
                         rescue SocketError => e
                           raise StandardError.new("Error accessing uri[#{full_uri(request.path)}]: #{e}")
                         end

              case response
              when Net::HTTPSuccess
                response.body
              else
                body = response.body rescue nil
                raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => full_uri(request.path).to_s)
              end
            end

            def full_uri(path)
              File.join(@base_uri.to_s, path)
            end

            # Called to configure SSL if the base uri requires it
            def configure_ssl
              @client.use_ssl = true
              @client.verify_mode = OpenSSL::SSL::VERIFY_PEER
              @client.cert_store = OpenSSL::X509::Store.new
              @client.cert_store.set_default_paths
            end

          end

          class Request

            attr_reader :base_uri, :path, :full_uri

            def initialize(http_handler, base_uri, path)
              @http_handler = http_handler
              @base_uri = Preconditions.assert_class('base_uri', base_uri, URI)
              @path = Preconditions.assert_class('path', path, String)
              @full_uri = @base_uri.to_s + @path
              @params = nil
              @body = nil
              @auth = nil
              @headers = {}
              @header_keys_lower_case = []
            end

            def with_header(name, value)
              Preconditions.check_not_blank('name', name, "Header name is required")
              Preconditions.check_not_blank('value', value, "Header value is required")
              Preconditions.check_state(!@headers.has_key?(name),
                                        "Duplicate header named[%s]" % name)
              @headers[name] = value
              @header_keys_lower_case << name.downcase
              self
            end

            def with_auth(auth)
              Preconditions.assert_class('auth', auth, HttpClient::Authorization)
              Preconditions.check_state(@auth.nil?, "auth previously set")

              if auth.scheme.name == AuthScheme::BASIC.name
                @auth = auth
              else
                raise "Auth Scheme[#{auth.scheme.name}] not supported"
              end
              self
            end

            def with_query(params)
              Preconditions.assert_class('params', params, Hash)
              Preconditions.check_state(@params.nil?, "Already have query parameters")
              @params = params
              self
            end

            # Wrapper to set Content-Type header to application/json and set
            # the provided json document as the body
            def with_json(json)
              @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
              with_body(json)
            end

            def with_body(body)
              Preconditions.check_not_blank('body', body)
              @body = body
              self
            end

            def get(&block)
              do_request(Net::HTTP::Get, &block)
            end

            def delete(&block)
              do_request(Net::HTTP::Delete, &block)
            end

            def options(&block)
              do_request(Net::HTTP::Options, &block)
            end

            def post(&block)
              do_request(Net::HTTP::Post, &block)
            end

            def put(&block)
              do_request(Net::HTTP::Put, &block)
            end

            class PATCH < Net::HTTP::Put
              METHOD = "PATCH"
            end

            def patch(&block)
              do_request(PATCH, &block)
            end

            def do_request(klass)
              Preconditions.assert_class('klass', klass, Class)

              uri = @full_uri.dup
              if q = to_query(@params)
                uri += "?%s" % q
              end

              request = klass.send(:new, uri)

              curl = ['curl']
              if klass != Net::HTTP::Get
                curl << "-X%s" % klass.name.split("::").last.upcase
              end

              if @body
                # DEBUG path = "/tmp/rest_client.tmp"
                # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                # DEBUG curl << "-d@%s" % path
                request.body = @body
              end

              if @auth
                curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                          "Cannot specify both an Authorization header and an auth instance")
                user_pass = "%s:%s" % [@auth.username, @auth.password]
                encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                request.add_field("Authorization", "Basic %s" % encoded)
              end

              @headers.each { |key, value|
                curl <<  "-H \"%s: %s\"" % [key, value]
                request.add_field(key, value)
              }

              curl << "'%s%s'" % [@base_uri, path]
              # DEBUG puts curl.join(" ")

              raw_response = @http_handler.instance(@base_uri, request.path).execute(request)
              response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

              if block_given?
                yield response
              else
                response
              end
            end

            private
            def to_query(params={})
              parts = (params || {}).map { |k,v|
                if v.is_a?(Enumerable)
                  v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                else
                  "%s=%s" % [k, CGI.escape(v.to_s)]
                end
              }
              parts.empty? ? nil : parts.join("&")
            end

          end

          class ServerError < StandardError

            attr_reader :code, :details, :body, :uri

            def initialize(code, details, incoming={})
              opts = HttpClient::Helper.symbolize_keys(incoming)
              @code = HttpClient::Preconditions.assert_class('code', code, Integer)
              @details = HttpClient::Preconditions.assert_class('details', details, String)
              @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
              @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
              HttpClient::Preconditions.assert_empty_opts(opts)
              super(self.message)
            end

            def message
              m = "%s %s" % [@code, @details]
              if @body
                m << ": %s" % @body
              end
              m
            end

            def body_json
              @body ? JSON.parse(@body) : nil
            end

          end

          class PreconditionException < StandardError

            attr_reader :message

            def initialize(message)
              super(message)
              @message = message
            end

          end

          module Preconditions

            def Preconditions.check_argument(expression, error_message=nil)
              if !expression
                raise PreconditionException.new(error_message || "check_argument failed")
              end
              nil
            end

            def Preconditions.check_state(expression, error_message=nil)
              if !expression
                raise PreconditionException.new(error_message || "check_state failed")
              end
              nil
            end

            def Preconditions.check_not_nil(field_name, reference, error_message=nil)
              if reference.nil?
                raise PreconditionException.new(error_message || "argument for %s cannot be nil" % field_name)
              end
              reference
            end

            def Preconditions.check_not_blank(field_name, reference, error_message=nil)
              if reference.to_s.strip == ""
                raise PreconditionException.new(error_message || "argument for %s cannot be blank" % field_name)
              end
              reference
            end

            # Throws an error if opts is not empty. Useful when parsing
            # arguments to a function
            def Preconditions.assert_empty_opts(opts)
              if !opts.empty?
                raise PreconditionException.new("Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}")
              end
            end

            # Requires that the provided hash has the specified keys.
            # @param fields A list of symbols
            def Preconditions.require_keys(hash, fields, error_prefix=nil)
              missing = fields.select { |f| !hash.has_key?(f) }
              if !missing.empty?
                msg = "Missing required fields: " + missing.join(", ")
                raise PreconditionException.new(error_prefix.empty? ? msg : "#{error_prefix}: #{msg}")
              end
            end

            # Asserts that value is not nill and is_?(klass). Returns
            # value. Common use is
            #
            # amount = Preconditions.assert_class('amount', amount, BigDecimal)
            def Preconditions.assert_class(field_name, value, klass)
              Preconditions.check_not_nil('field_name', field_name)
              Preconditions.check_not_nil('klass', klass)
              Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
              Preconditions.check_state(value.is_a?(klass),
                                        "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
              value
            end

            def Preconditions.assert_class_or_nil(field_name, value, klass)
              if !value.nil?
                Preconditions.assert_class(field_name, value, klass)
              end
            end

            def Preconditions.assert_boolean(field_name, value)
              Preconditions.check_not_nil('field_name', field_name)
              Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
              Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                        "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
              value
            end

            def Preconditions.assert_boolean_or_nil(field_name, value)
              if !value.nil?
                Preconditions.assert_boolean(field_name, value)
              end
            end

            def Preconditions.assert_collection_of_class(field_name, values, klass)
              Preconditions.assert_class(field_name, values, Array)
              values.each { |v| Preconditions.assert_class(field_name, v, klass) }
            end

            def Preconditions.assert_hash_of_class(field_name, hash, klass)
              Preconditions.assert_class(field_name, hash, Hash)
              values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
            end

          end

          class AuthScheme

            attr_reader :name

            def initialize(name)
              @name = HttpClient::Preconditions.check_not_blank('name', name)
            end

            BASIC = AuthScheme.new("basic") unless defined?(BASIC)

          end

          class Authorization

            attr_reader :scheme, :username, :password

            def initialize(scheme, username, opts={})
              @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
              @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
              @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
              HttpClient::Preconditions.assert_empty_opts(opts)
            end

            def Authorization.basic(username, password=nil)
              Authorization.new(AuthScheme::BASIC, username, :password => password)
            end

          end

          module Helper

            def Helper.symbolize_keys(hash)
              Preconditions.assert_class('hash', hash, Hash)
              new_hash = {}
              hash.each { |k, v|
                new_hash[k.to_sym] = v
              }
              new_hash
            end

            def Helper.to_big_decimal(value)
              value ? BigDecimal.new(value.to_s) : nil
            end

            def Helper.to_object(value)
              value ? (value.is_a?(Hash) ? value : JSON.parse(value)) : nil
            end

            def Helper.to_uuid(value)
              Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                        "Invalid guid[%s]" % value)
              value
            end

            def Helper.to_date_iso8601(value)
              if value.is_a?(Date)
                value
              elsif value
                Date.parse(value.to_s)
              else
                nil
              end
            end

            def Helper.to_date_time_iso8601(value)
              if value.is_a?(DateTime)
                value
              elsif value
                DateTime.parse(value.to_s)
              else
                nil
              end
            end

            def Helper.date_iso8601_to_string(value)
              value.nil? ? nil : value.strftime('%Y-%m-%d')
            end

            def Helper.date_time_iso8601_to_string(value)
              value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
            end

            TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
            FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

            def Helper.to_boolean(field_name, value)
              string = value.to_s.strip.downcase
              if TRUE_STRINGS.include?(string)
                true
              elsif FALSE_STRINGS.include?(string)
                false
              elsif string != ""
                raise PreconditionException.new("Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}")
              else
                nil
              end
            end

          end

        end
      end
    end
  end
end