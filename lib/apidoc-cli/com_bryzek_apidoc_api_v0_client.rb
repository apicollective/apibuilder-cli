# Generated by apidoc - http://www.apidoc.me
# Service version: 0.9.27-dev
# apidoc:0.9.26 http://www.apidoc.me/bryzek/apidoc-api/0.9.27-dev/ruby_client

require 'cgi'
require 'net/http'
require 'net/https'
require 'uri'
require 'base64'

require 'rubygems'
require 'json'
require 'bigdecimal'

# Host API documentation for applications providing REST APIs, facilitating the
# design of good resource first APIs.
module Com
  module Bryzek
    module Apidoc
      module Api
        module V0

          class Client

            module Constants

              USER_AGENT = 'apidoc:0.9.26 http://www.apidoc.me/bryzek/apidoc-api/0.9.27-dev/ruby_client' unless defined?(Constants::USER_AGENT)
              VERSION = '0.9.27-dev' unless defined?(Constants::VERSION)
              VERSION_MAJOR = 0 unless defined?(VERSION_MAJOR)

            end

            attr_reader :url

            def initialize(url, opts={})
              @url = HttpClient::Preconditions.assert_class('url', url, String)
              @authorization = HttpClient::Preconditions.assert_class_or_nil('authorization', opts.delete(:authorization), HttpClient::Authorization)
              @default_headers = HttpClient::Preconditions.assert_class('default_headers', opts.delete(:default_headers) || {}, Hash)
              HttpClient::Preconditions.assert_empty_opts(opts)
              HttpClient::Preconditions.check_state(url.match(/http.+/i), "URL[%s] must start with http" % url)
            end

            def request(path=nil)
              HttpClient::Preconditions.assert_class_or_nil('path', path, String)
              request = HttpClient::Request.new(URI.parse(@url + path.to_s)).with_header('User-Agent', Constants::USER_AGENT).with_header('X-Apidoc-Version', Constants::VERSION).with_header('X-Apidoc-Version-Major', Constants::VERSION_MAJOR)

              @default_headers.each do |key, value|
                request = request.with_header(key, value)
              end

              if @authorization
                request = request.with_auth(@authorization)
              end

              request
            end

            def applications
              @applications ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Applications.new(self)
            end

            def changes
              @changes ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Changes.new(self)
            end

            def code
              @code ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Code.new(self)
            end

            def com_bryzek_apidoc_generator_v0_models_generators
              @com_bryzek_apidoc_generator_v0_models_generators ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::ComBryzekApidocGeneratorV0ModelsGenerators.new(self)
            end

            def domains
              @domains ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Domains.new(self)
            end

            def email_verification_confirmation_forms
              @email_verification_confirmation_forms ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::EmailVerificationConfirmationForms.new(self)
            end

            def generator_services
              @generator_services ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::GeneratorServices.new(self)
            end

            def healthchecks
              @healthchecks ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Healthchecks.new(self)
            end

            def items
              @items ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Items.new(self)
            end

            def memberships
              @memberships ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Memberships.new(self)
            end

            def membership_requests
              @membership_requests ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::MembershipRequests.new(self)
            end

            def organizations
              @organizations ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Organizations.new(self)
            end

            def password_resets
              @password_resets ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::PasswordResets.new(self)
            end

            def password_reset_requests
              @password_reset_requests ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::PasswordResetRequests.new(self)
            end

            def subscriptions
              @subscriptions ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Subscriptions.new(self)
            end

            def tokens
              @tokens ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Tokens.new(self)
            end

            def users
              @users ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Users.new(self)
            end

            def validations
              @validations ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Validations.new(self)
            end

            def versions
              @versions ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Versions.new(self)
            end

            def watches
              @watches ||= ::Com::Bryzek::Apidoc::Api::V0::Clients::Watches.new(self)
            end
          end

          module Clients

            class Applications

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search all applications. Results are always paginated.
              def get_by_org_key(org_key, incoming={})
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                  :has_version => (x = opts.delete(:has_version); x.nil? ? nil : HttpClient::Preconditions.assert_boolean('has_version', x)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/#{CGI.escape(org_key)}").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Application.new(x) }
              end

              # Create an application.
              def post_by_org_key(org_key, application_form)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_form', application_form, ::Com::Bryzek::Apidoc::Api::V0::Models::ApplicationForm)
                r = @client.request("/#{CGI.escape(org_key)}").with_json(application_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Application.new(r)
              end

              # Updates an application.
              def put_by_org_key_and_application_key(org_key, application_key, application_form)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('application_form', application_form, ::Com::Bryzek::Apidoc::Api::V0::Models::ApplicationForm)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").with_json(application_form.to_json).put
                ::Com::Bryzek::Apidoc::Api::V0::Models::Application.new(r)
              end

              # Deletes a specific application and its associated versions.
              def delete_by_org_key_and_application_key(org_key, application_key)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").delete
                nil
              end

              # Moves application to a new organization.
              def post_move_by_org_key_and_application_key(org_key, application_key, move_form)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('move_form', move_form, ::Com::Bryzek::Apidoc::Api::V0::Models::MoveForm)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/move").with_json(move_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Application.new(r)
              end

            end

            class Changes

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                  :application_key => (x = opts.delete(:application_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('application_key', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/changes").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Change.new(x) }
              end

            end

            class Code

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Generate code for a specific version of an application.
              def get_by_org_key_and_application_key_and_version_and_generator_key(org_key, application_key, version, generator_key)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('version', version, String)
                HttpClient::Preconditions.assert_class('generator_key', generator_key, String)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}/#{CGI.escape(generator_key)}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Code.new(r)
              end

            end

            class ComBryzekApidocGeneratorV0ModelsGenerators

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # List all generators visible by this user
              def get_generators(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :service_uri => (x = opts.delete(:service_uri); x.nil? ? nil : HttpClient::Preconditions.assert_class('service_uri', x, String)),
                  :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 100 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/generators").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Generator::V0::Models::Generator.new(x) }
              end

              def get_generators_by_key(key)
                HttpClient::Preconditions.assert_class('key', key, String)
                r = @client.request("/generators/#{CGI.escape(key)}").get
                ::Com::Bryzek::Apidoc::Generator::V0::Models::Generator.new(r)
              end

            end

            class Domains

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Add a domain to this organization
              def post_by_org_key(org_key, domain)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('domain', domain, ::Com::Bryzek::Apidoc::Api::V0::Models::Domain)
                r = @client.request("/domains/#{CGI.escape(org_key)}").with_json(domain.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Domain.new(r)
              end

              # Remove this domain from this organization
              def delete_by_org_key_and_name(org_key, name)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('name', name, String)
                r = @client.request("/domains/#{CGI.escape(org_key)}/#{CGI.escape(name)}").delete
                nil
              end

            end

            class EmailVerificationConfirmationForms

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Validate an email address using a token.
              def post_email_verification_confirmations(email_verification_confirmation_form)
                HttpClient::Preconditions.assert_class('email_verification_confirmation_form', email_verification_confirmation_form, ::Com::Bryzek::Apidoc::Api::V0::Models::EmailVerificationConfirmationForm)
                r = @client.request("/email_verification_confirmations").with_json(email_verification_confirmation_form.to_json).post
                nil
              end

            end

            class GeneratorServices

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # List all generator services
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :uri => (x = opts.delete(:uri); x.nil? ? nil : HttpClient::Preconditions.assert_class('uri', x, String)),
                  :generator_key => (x = opts.delete(:generator_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('generator_key', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 100 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/generator_services").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::GeneratorService.new(x) }
              end

              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/generator_services/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::GeneratorService.new(r)
              end

              def post(generator_service_form)
                HttpClient::Preconditions.assert_class('generator_service_form', generator_service_form, ::Com::Bryzek::Apidoc::Api::V0::Models::GeneratorServiceForm)
                r = @client.request("/generator_services").with_json(generator_service_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::GeneratorService.new(r)
              end

              # Deletes a generator service.
              def delete_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/generator_services/#{guid}").delete
                nil
              end

            end

            class Healthchecks

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              def get_internal_and_healthcheck
                r = @client.request("/_internal_/healthcheck").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Healthcheck.new(r)
              end

              def get_internal_and_migrate
                r = @client.request("/_internal_/migrate").get
                r.inject({}) { |hash, x| hash[x[0]] = x[1].nil? ? nil : ::Com::Bryzek::Apidoc::Api::V0::Models::Value.new(x[1]); hash }
              end

            end

            class Items

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :q => (x = opts.delete(:q); x.nil? ? nil : HttpClient::Preconditions.assert_class('q', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/items").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Item.new(x) }
              end

              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/items/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Item.new(r)
              end

            end

            class Memberships

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search all memberships. Results are always paginated.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :org_guid => (x = opts.delete(:org_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_guid', HttpClient::Helper.to_uuid(x), String)),
                  :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/memberships").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Membership.new(x) }
              end

              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/memberships/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Membership.new(r)
              end

              def delete_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/memberships/#{guid}").delete
                nil
              end

            end

            class MembershipRequests

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search all membership requests. Results are always paginated.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :org_guid => (x = opts.delete(:org_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_guid', HttpClient::Helper.to_uuid(x), String)),
                  :org_key => (x = opts.delete(:org_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('org_key', x, String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :role => (x = opts.delete(:role); x.nil? ? nil : HttpClient::Preconditions.assert_class('role', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/membership_requests").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::MembershipRequest.new(x) }
              end

              # Create a membership request
              def post(hash)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                r = @client.request("/membership_requests").with_json(hash.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::MembershipRequest.new(r)
              end

              # Accepts this membership request. User will become a member of the specified
              # organization.
              def post_accept_by_guid(guid, hash)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                r = @client.request("/membership_requests/#{guid}/accept").with_json(hash.to_json).post
                nil
              end

              # Declines this membership request. User will NOT become a member of the
              # specified organization.
              def post_decline_by_guid(guid, hash)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                r = @client.request("/membership_requests/#{guid}/decline").with_json(hash.to_json).post
                nil
              end

            end

            class Organizations

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search all organizations. Results are always paginated.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :key => (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String)),
                  :name => (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String)),
                  :namespace => (x = opts.delete(:namespace); x.nil? ? nil : HttpClient::Preconditions.assert_class('namespace', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/organizations").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(x) }
              end

              # Returns the organization with this key.
              def get_by_key(key)
                HttpClient::Preconditions.assert_class('key', key, String)
                r = @client.request("/organizations/#{CGI.escape(key)}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(r)
              end

              # Create a new organization.
              def post(organization_form)
                HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Com::Bryzek::Apidoc::Api::V0::Models::OrganizationForm)
                r = @client.request("/organizations").with_json(organization_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(r)
              end

              # Update an organization.
              def put_by_key(key, organization_form)
                HttpClient::Preconditions.assert_class('key', key, String)
                HttpClient::Preconditions.assert_class('organization_form', organization_form, ::Com::Bryzek::Apidoc::Api::V0::Models::OrganizationForm)
                r = @client.request("/organizations/#{CGI.escape(key)}").with_json(organization_form.to_json).put
                ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(r)
              end

              # Deletes an organization and all of its associated applications.
              def delete_by_key(key)
                HttpClient::Preconditions.assert_class('key', key, String)
                r = @client.request("/organizations/#{CGI.escape(key)}").delete
                nil
              end

            end

            class PasswordResets

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Change the password for this token. If the token is invalid, has been used,
              # or otherwise no longer can be applied, errors will be returned as 409s. A
              # 204 represents that the user has successfully changed their password.
              def post(password_reset)
                HttpClient::Preconditions.assert_class('password_reset', password_reset, ::Com::Bryzek::Apidoc::Api::V0::Models::PasswordReset)
                r = @client.request("/password_resets").with_json(password_reset.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::PasswordResetSuccess.new(r)
              end

            end

            class PasswordResetRequests

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Create a new password reset. This will send the user an email with a link to
              # reset their password.
              def post(password_reset_request)
                HttpClient::Preconditions.assert_class('password_reset_request', password_reset_request, ::Com::Bryzek::Apidoc::Api::V0::Models::PasswordResetRequest)
                r = @client.request("/password_reset_requests").with_json(password_reset_request.to_json).post
                nil
              end

            end

            class Subscriptions

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search subscriptions. Always paginated.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :organization_key => (x = opts.delete(:organization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_key', x, String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :publication => (x = opts.delete(:publication); x.nil? ? nil : (x = x; x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Publication) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Publication.apply(x))),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/subscriptions").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Subscription.new(x) }
              end

              # Returns information about a specific subscription.
              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/subscriptions/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Subscription.new(r)
              end

              # Create a new subscription.
              def post(subscription_form)
                HttpClient::Preconditions.assert_class('subscription_form', subscription_form, ::Com::Bryzek::Apidoc::Api::V0::Models::SubscriptionForm)
                r = @client.request("/subscriptions").with_json(subscription_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Subscription.new(r)
              end

              def delete_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/subscriptions/#{guid}").delete
                nil
              end

            end

            class Tokens

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              def get_users_by_user_guid(user_guid, incoming={})
                HttpClient::Preconditions.assert_class('user_guid', user_guid, String)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/tokens/users/#{user_guid}").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Token.new(x) }
              end

              # Used to fetch the clear text token.
              def get_cleartext_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/tokens/#{guid}/cleartext").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::CleartextToken.new(r)
              end

              # Create a new API token for this user
              def post(token_form)
                HttpClient::Preconditions.assert_class('token_form', token_form, ::Com::Bryzek::Apidoc::Api::V0::Models::TokenForm)
                r = @client.request("/tokens").with_json(token_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Token.new(r)
              end

              def delete_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/tokens/#{guid}").delete
                nil
              end

            end

            class Users

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search for a specific user. You must specify at least 1 parameter - either a
              # guid, email or token - and will receive back either 0 or 1 users.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :email => (x = opts.delete(:email); x.nil? ? nil : HttpClient::Preconditions.assert_class('email', x, String)),
                  :token => (x = opts.delete(:token); x.nil? ? nil : HttpClient::Preconditions.assert_class('token', x, String))
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/users").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x) }
              end

              # Returns information about the user with this guid.
              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/users/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(r)
              end

              # Used to authenticate a user with an email address and password. Successful
              # authentication returns an instance of the user model. Failed authorizations
              # of any kind are returned as a generic error with code
              # user_authorization_failed.
              def post_authenticate(hash)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                r = @client.request("/users/authenticate").with_json(hash.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(r)
              end

              # Create a new user.
              def post(user_form)
                HttpClient::Preconditions.assert_class('user_form', user_form, ::Com::Bryzek::Apidoc::Api::V0::Models::UserForm)
                r = @client.request("/users").with_json(user_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(r)
              end

              # Updates information about the user with the specified guid.
              def put_by_guid(guid, user_update_form)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                HttpClient::Preconditions.assert_class('user_update_form', user_update_form, ::Com::Bryzek::Apidoc::Api::V0::Models::UserUpdateForm)
                r = @client.request("/users/#{guid}").with_json(user_update_form.to_json).put
                ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(r)
              end

            end

            class Validations

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              def post(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                r = @client.request("/validations").with_body(value).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Validation.new(r)
              end

            end

            class Versions

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search all versions of this application. Results are always paginated.
              def get_by_org_key_and_application_key(org_key, application_key, incoming={})
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Version.new(x) }
              end

              # Retrieve a specific version of an application.
              def get_by_org_key_and_application_key_and_version(org_key, application_key, version)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('version', version, String)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Version.new(r)
              end

              # Create a new version for an application
              def post_by_org_key_and_version(org_key, version, version_form)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('version', version, String)
                HttpClient::Preconditions.assert_class('version_form', version_form, ::Com::Bryzek::Apidoc::Api::V0::Models::VersionForm)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(version)}").with_json(version_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Version.new(r)
              end

              # Upsert a version of an application
              def put_by_org_key_and_application_key_and_version(org_key, application_key, version, version_form)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('version', version, String)
                HttpClient::Preconditions.assert_class('version_form', version_form, ::Com::Bryzek::Apidoc::Api::V0::Models::VersionForm)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").with_json(version_form.to_json).put
                ::Com::Bryzek::Apidoc::Api::V0::Models::Version.new(r)
              end

              # Deletes a specific version.
              def delete_by_org_key_and_application_key_and_version(org_key, application_key, version)
                HttpClient::Preconditions.assert_class('org_key', org_key, String)
                HttpClient::Preconditions.assert_class('application_key', application_key, String)
                HttpClient::Preconditions.assert_class('version', version, String)
                r = @client.request("/#{CGI.escape(org_key)}/#{CGI.escape(application_key)}/#{CGI.escape(version)}").delete
                nil
              end

            end

            class Watches

              def initialize(client)
                @client = HttpClient::Preconditions.assert_class('client', client, ::Com::Bryzek::Apidoc::Api::V0::Client)
              end

              # Search watches. Always paginated.
              def get(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :guid => (x = opts.delete(:guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(x), String)),
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :organization_key => (x = opts.delete(:organization_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('organization_key', x, String)),
                  :application_key => (x = opts.delete(:application_key); x.nil? ? nil : HttpClient::Preconditions.assert_class('application_key', x, String)),
                  :limit => HttpClient::Preconditions.assert_class('limit', (x = opts.delete(:limit); x.nil? ? 25 : x), Integer),
                  :offset => HttpClient::Preconditions.assert_class('offset', (x = opts.delete(:offset); x.nil? ? 0 : x), Integer)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/watches").with_query(query).get
                r.map { |x| ::Com::Bryzek::Apidoc::Api::V0::Models::Watch.new(x) }
              end

              # Returns information about a specific watch.
              def get_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/watches/#{guid}").get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Watch.new(r)
              end

              # Quick check if a user is watching a specific application.
              def get_check(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                query = {
                  :user_guid => (x = opts.delete(:user_guid); x.nil? ? nil : HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(x), String)),
                  :organization_key => HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String),
                  :application_key => HttpClient::Preconditions.assert_class('application_key', opts.delete(:application_key), String)
                }.delete_if { |k, v| v.nil? }
                r = @client.request("/watches/check").with_query(query).get
                ::Com::Bryzek::Apidoc::Api::V0::Models::Value.new(r)
              end

              # Create a new watch.
              def post(watch_form)
                HttpClient::Preconditions.assert_class('watch_form', watch_form, ::Com::Bryzek::Apidoc::Api::V0::Models::WatchForm)
                r = @client.request("/watches").with_json(watch_form.to_json).post
                ::Com::Bryzek::Apidoc::Api::V0::Models::Watch.new(r)
              end

              def delete_by_guid(guid)
                HttpClient::Preconditions.assert_class('guid', guid, String)
                r = @client.request("/watches/#{guid}").delete
                nil
              end

            end

          end

          module Models

            # Represents a single diff in an application
            class Diff

              module Types
                DIFF_BREAKING = 'diff_breaking' unless defined?(DIFF_BREAKING)
                DIFF_NON_BREAKING = 'diff_non_breaking' unless defined?(DIFF_NON_BREAKING)
              end

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def to_hash
                { @name => subtype_to_hash }
              end

              def Diff.from_json(hash)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                hash.map do |union_type_name, data|
                  case union_type_name
                    when Types::DIFF_BREAKING; DiffBreaking.new(data)
                    when Types::DIFF_NON_BREAKING; DiffNonBreaking.new(data)
                    else DiffUndefinedType.new(:name => union_type_name)
                  end
                end.first
              end

            end

            class DiffUndefinedType < Diff

              attr_reader :name

              def initialize(incoming={})
                super(:name => 'undefined_type')
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def subtype_to_hash
                raise 'Unable to serialize undefined type to json'
              end

              def copy(incoming={})
                raise 'Operation not supported for undefined type'
              end

              def to_hash
                raise 'Operation not supported for undefined type'
              end

            end

            # Identifies the specific type of item that was indexed by search
            class ItemDetail

              module Types
                # Represents that the item indexed was an application
                APPLICATION_SUMMARY = 'application_summary' unless defined?(APPLICATION_SUMMARY)
              end

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def to_hash
                { @name => subtype_to_hash }
              end

              def ItemDetail.from_json(hash)
                HttpClient::Preconditions.assert_class('hash', hash, Hash)
                hash.map do |union_type_name, data|
                  case union_type_name
                    when Types::APPLICATION_SUMMARY; ApplicationSummary.new(data)
                    else ItemDetailUndefinedType.new(:name => union_type_name)
                  end
                end.first
              end

            end

            class ItemDetailUndefinedType < ItemDetail

              attr_reader :name

              def initialize(incoming={})
                super(:name => 'undefined_type')
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def subtype_to_hash
                raise 'Unable to serialize undefined type to json'
              end

              def copy(incoming={})
                raise 'Operation not supported for undefined type'
              end

              def to_hash
                raise 'Operation not supported for undefined type'
              end

            end

            class OriginalType

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of OriginalType for this value, creating a new instance for an unknown value
              def OriginalType.apply(value)
                if value.instance_of?(OriginalType)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || OriginalType.new(value))
                end
              end

              # Returns the instance of OriginalType for this value, or nil if not found
              def OriginalType.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                OriginalType.ALL.find { |v| v.value == value }
              end

              def OriginalType.ALL
                @@all ||= [OriginalType.api_json, OriginalType.swagger_json, OriginalType.avro_idl]
              end

              # The original is in the api.json format
              def OriginalType.api_json
                @@_api_json ||= OriginalType.new('api_json')
              end

              # The original in the swagger.json format
              def OriginalType.swagger_json
                @@_swagger_json ||= OriginalType.new('swagger_json')
              end

              # The original is in Avro Idl format
              def OriginalType.avro_idl
                @@_avro_idl ||= OriginalType.new('avro_idl')
              end

              def to_hash
                value
              end

            end

            class Publication

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of Publication for this value, creating a new instance for an unknown value
              def Publication.apply(value)
                if value.instance_of?(Publication)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || Publication.new(value))
                end
              end

              # Returns the instance of Publication for this value, or nil if not found
              def Publication.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                Publication.ALL.find { |v| v.value == value }
              end

              def Publication.ALL
                @@all ||= [Publication.membership_requests_create, Publication.memberships_create, Publication.applications_create, Publication.versions_create]
              end

              # For organizations for which I am an administrator, email me whenever a user
              # applies to join the org.
              def Publication.membership_requests_create
                @@_membership_requests_create ||= Publication.new('membership_requests.create')
              end

              # For organizations for which I am a member, email me whenever a user joins the
              # org.
              def Publication.memberships_create
                @@_memberships_create ||= Publication.new('memberships.create')
              end

              # For organizations for which I am a member, email me whenever an application is
              # created.
              def Publication.applications_create
                @@_applications_create ||= Publication.new('applications.create')
              end

              # For applications that I watch, email me whenever a version is created.
              def Publication.versions_create
                @@_versions_create ||= Publication.new('versions.create')
              end

              def to_hash
                value
              end

            end

            class Visibility

              attr_reader :value

              def initialize(value)
                @value = HttpClient::Preconditions.assert_class('value', value, String)
              end

              # Returns the instance of Visibility for this value, creating a new instance for an unknown value
              def Visibility.apply(value)
                if value.instance_of?(Visibility)
                  value
                else
                  HttpClient::Preconditions.assert_class_or_nil('value', value, String)
                  value.nil? ? nil : (from_string(value) || Visibility.new(value))
                end
              end

              # Returns the instance of Visibility for this value, or nil if not found
              def Visibility.from_string(value)
                HttpClient::Preconditions.assert_class('value', value, String)
                Visibility.ALL.find { |v| v.value == value }
              end

              def Visibility.ALL
                @@all ||= [Visibility.user, Visibility.organization, Visibility.public]
              end

              # Only the creator can view this application
              def Visibility.user
                @@_user ||= Visibility.new('user')
              end

              # Any member of the organization can view this application
              def Visibility.organization
                @@_organization ||= Visibility.new('organization')
              end

              # Anybody, including non logged in users, can view this application
              def Visibility.public
                @@_public ||= Visibility.new('public')
              end

              def to_hash
                value
              end

            end

            # An application has a name and multiple versions of its API.
            class Application

              attr_reader :guid, :organization, :name, :key, :visibility, :description, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
                @visibility = (x = opts.delete(:visibility); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Visibility) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Visibility.apply(x))
                @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Application.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :name => name,
                  :key => key,
                  :visibility => visibility.value,
                  :description => description,
                  :audit => audit.to_hash
                }
              end

            end

            class ApplicationForm

              attr_reader :name, :key, :description, :visibility

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
                @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
                @visibility = (x = opts.delete(:visibility); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Visibility) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Visibility.apply(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                ApplicationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :key => key,
                  :description => description,
                  :visibility => visibility.value
                }
              end

            end

            # Summary of an application sufficient for display and links
            class ApplicationSummary < ItemDetail

              attr_reader :guid, :organization, :key

              def initialize(incoming={})
                super(:name => ItemDetail::Types::APPLICATION_SUMMARY)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                ApplicationSummary.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def subtype_to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :key => key
                }
              end

            end

            class Audit

              attr_reader :created_at, :created_by, :updated_at, :updated_by

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @created_at = HttpClient::Preconditions.assert_class('created_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:created_at)), DateTime)
                @created_by = (x = opts.delete(:created_by); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::ReferenceGuid) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::ReferenceGuid.new(x))
                @updated_at = HttpClient::Preconditions.assert_class('updated_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:updated_at)), DateTime)
                @updated_by = (x = opts.delete(:updated_by); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::ReferenceGuid) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::ReferenceGuid.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Audit.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :created_at => created_at,
                  :created_by => created_by.to_hash,
                  :updated_at => updated_at,
                  :updated_by => updated_by.to_hash
                }
              end

            end

            # Represents a single change from one version of a service to another
            class Change

              attr_reader :guid, :organization, :application, :from_version, :to_version, :diff, :changed_at, :changed_by, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @application = (x = opts.delete(:application); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @from_version = (x = opts.delete(:from_version); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::ChangeVersion) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::ChangeVersion.new(x))
                @to_version = (x = opts.delete(:to_version); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::ChangeVersion) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::ChangeVersion.new(x))
                @diff = (x = opts.delete(:diff); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Diff) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Diff.from_json(x))
                @changed_at = HttpClient::Preconditions.assert_class('changed_at', HttpClient::Helper.to_date_time_iso8601(opts.delete(:changed_at)), DateTime)
                @changed_by = (x = opts.delete(:changed_by); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::UserSummary) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::UserSummary.new(x))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Change.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :application => application.to_hash,
                  :from_version => from_version.to_hash,
                  :to_version => to_version.to_hash,
                  :diff => diff.to_hash,
                  :changed_at => changed_at,
                  :changed_by => changed_by.to_hash,
                  :audit => audit.to_hash
                }
              end

            end

            # Represents a simpler model of a version specifically for the use case of
            # displaying changes
            class ChangeVersion

              attr_reader :guid, :version

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                ChangeVersion.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :version => version
                }
              end

            end

            # Separate resource used only for the few actions that require the full token.
            class CleartextToken

              attr_reader :token

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                CleartextToken.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :token => token
                }
              end

            end

            # Generated source code.
            class Code

              attr_reader :generator, :source

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @generator = (x = opts.delete(:generator); x.is_a?(::Com::Bryzek::Apidoc::Generator::V0::Models::Generator) ? x : ::Com::Bryzek::Apidoc::Generator::V0::Models::Generator.new(x))
                @source = HttpClient::Preconditions.assert_class('source', opts.delete(:source), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Code.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :generator => generator.to_hash,
                  :source => source
                }
              end

            end

            # Represents a single breaking diff of an application version. A breaking diff
            # indicates that it is possible for an existing client to now experience an
            # error or invalid data due to the diff.
            class DiffBreaking < Diff

              attr_reader :description

              def initialize(incoming={})
                super(:name => Diff::Types::DIFF_BREAKING)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                DiffBreaking.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def subtype_to_hash
                {
                  :description => description
                }
              end

            end

            # Represents a single NON breaking diff of an application version.
            class DiffNonBreaking < Diff

              attr_reader :description

              def initialize(incoming={})
                super(:name => Diff::Types::DIFF_NON_BREAKING)
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @description = HttpClient::Preconditions.assert_class('description', opts.delete(:description), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                DiffNonBreaking.new(subtype_to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def subtype_to_hash
                {
                  :description => description
                }
              end

            end

            # Represents a single domain name (e.g. www.apidoc.me). When a new user
            # registers and confirms their email, we automatically associate that user with
            # a member of the organization associated with their domain. For example, if you
            # confirm your account with an email address of foo@bryzek.com, we will
            # automatically create a membership request on your behalf to join the
            # organization with domain bryzek.com.
            class Domain

              attr_reader :name

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Domain.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name
                }
              end

            end

            # Data used to confirm an email address. The token is an internal unique
            # identifier used to lookup the specific email address and user account for
            # which we sent an email verification email.
            class EmailVerificationConfirmationForm

              attr_reader :token

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                EmailVerificationConfirmationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :token => token
                }
              end

            end

            class Error

              attr_reader :code, :message

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @code = HttpClient::Preconditions.assert_class('code', opts.delete(:code), String)
                @message = HttpClient::Preconditions.assert_class('message', opts.delete(:message), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Error.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :code => code,
                  :message => message
                }
              end

            end

            # Defines a service that provides one or more code generators
            class GeneratorService

              attr_reader :guid, :uri, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @uri = HttpClient::Preconditions.assert_class('uri', opts.delete(:uri), String)
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                GeneratorService.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :uri => uri,
                  :audit => audit.to_hash
                }
              end

            end

            class GeneratorServiceForm

              attr_reader :uri

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @uri = HttpClient::Preconditions.assert_class('uri', opts.delete(:uri), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                GeneratorServiceForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :uri => uri
                }
              end

            end

            class Healthcheck

              attr_reader :status

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @status = HttpClient::Preconditions.assert_class('status', opts.delete(:status), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Healthcheck.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :status => status
                }
              end

            end

            # When searching for content, the results of the search will be a list of items.
            # Each item will have enough information to render for the user, including a
            # type and item_guid to enable creating the appropriate link.
            class Item

              attr_reader :guid, :detail, :label, :description

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @detail = (x = opts.delete(:detail); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::ItemDetail) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::ItemDetail.from_json(x))
                @label = HttpClient::Preconditions.assert_class('label', opts.delete(:label), String)
                @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Item.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :detail => detail.to_hash,
                  :label => label,
                  :description => description
                }
              end

            end

            # A membership represents a user in a specific role to an organization.
            # Memberships cannot be created directly. Instead you first create a membership
            # request, then that request is either accepted or declined.
            class Membership

              attr_reader :guid, :user, :organization, :role, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @user = (x = opts.delete(:user); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::User) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x))
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Organization) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(x))
                @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Membership.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :user => user.to_hash,
                  :organization => organization.to_hash,
                  :role => role,
                  :audit => audit.to_hash
                }
              end

            end

            # A membership request represents a user requesting to join an organization with
            # a specific role (e.g. as a member or an admin). Membership requests can be
            # reviewed by any current admin of the organization who can either accept or
            # decline the request.
            class MembershipRequest

              attr_reader :guid, :user, :organization, :role, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @user = (x = opts.delete(:user); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::User) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x))
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Organization) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(x))
                @role = HttpClient::Preconditions.assert_class('role', opts.delete(:role), String)
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                MembershipRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :user => user.to_hash,
                  :organization => organization.to_hash,
                  :role => role,
                  :audit => audit.to_hash
                }
              end

            end

            class MoveForm

              attr_reader :org_key

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @org_key = HttpClient::Preconditions.assert_class('org_key', opts.delete(:org_key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                MoveForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :org_key => org_key
                }
              end

            end

            # An organization is used to group a set of applications together.
            class Organization

              attr_reader :guid, :key, :name, :namespace, :visibility, :domains, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
                @visibility = (x = opts.delete(:visibility); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Visibility) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Visibility.apply(x))
                @domains = HttpClient::Preconditions.assert_class('domains', (x = opts.delete(:domains); x.nil? ? [] : x), Array).map { |v| (x = v; x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Domain) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Domain.new(x)) }
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Organization.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :key => key,
                  :name => name,
                  :namespace => namespace,
                  :visibility => visibility.value,
                  :domains => domains.map { |o| o.to_hash },
                  :audit => audit.to_hash
                }
              end

            end

            class OrganizationForm

              attr_reader :name, :key, :namespace, :visibility, :domains

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @name = HttpClient::Preconditions.assert_class('name', opts.delete(:name), String)
                @key = (x = opts.delete(:key); x.nil? ? nil : HttpClient::Preconditions.assert_class('key', x, String))
                @namespace = HttpClient::Preconditions.assert_class('namespace', opts.delete(:namespace), String)
                @visibility = (x = (x = opts.delete(:visibility); x.nil? ? Visibility.apply("organization") : x); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Visibility) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Visibility.apply(x))
                @domains = (x = opts.delete(:domains); x.nil? ? nil : HttpClient::Preconditions.assert_class('domains', x, Array).map { |v| HttpClient::Preconditions.assert_class('domains', v, String) })
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                OrganizationForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :name => name,
                  :key => key,
                  :namespace => namespace,
                  :visibility => visibility.value,
                  :domains => domains.nil? ? nil : domains
                }
              end

            end

            # Represents the original input used to create an application version
            class Original

              attr_reader :type, :data

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @type = (x = opts.delete(:type); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::OriginalType) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::OriginalType.apply(x))
                @data = HttpClient::Preconditions.assert_class('data', opts.delete(:data), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Original.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :type => type.value,
                  :data => data
                }
              end

            end

            class OriginalForm

              attr_reader :type, :data

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @type = (x = opts.delete(:type); x.nil? ? nil : (x = x; x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::OriginalType) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::OriginalType.apply(x)))
                @data = HttpClient::Preconditions.assert_class('data', opts.delete(:data), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                OriginalForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :type => type.nil? ? nil : type.value,
                  :data => data
                }
              end

            end

            # Allows a user to change their password with authentication from a token.
            class PasswordReset

              attr_reader :token, :password

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @token = HttpClient::Preconditions.assert_class('token', opts.delete(:token), String)
                @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                PasswordReset.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :token => token,
                  :password => password
                }
              end

            end

            # Create a password reset request - e.g. an email containing a one time URL to
            # change a password
            class PasswordResetRequest

              attr_reader :email

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                PasswordResetRequest.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :email => email
                }
              end

            end

            # On a successful password reset, return some metadata about the user modified.
            class PasswordResetSuccess

              attr_reader :user_guid

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                PasswordResetSuccess.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :user_guid => user_guid
                }
              end

            end

            # Represents a reference to another model.
            class Reference

              attr_reader :guid, :key

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @key = HttpClient::Preconditions.assert_class('key', opts.delete(:key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Reference.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :key => key
                }
              end

            end

            class ReferenceGuid

              attr_reader :guid

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                ReferenceGuid.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid
                }
              end

            end

            # Represents a user that is currently subscribed to a publication
            class Subscription

              attr_reader :guid, :organization, :user, :publication, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Organization) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(x))
                @user = (x = opts.delete(:user); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::User) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x))
                @publication = (x = opts.delete(:publication); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Publication) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Publication.apply(x))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Subscription.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :user => user.to_hash,
                  :publication => publication.value,
                  :audit => audit.to_hash
                }
              end

            end

            class SubscriptionForm

              attr_reader :organization_key, :user_guid, :publication

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @organization_key = HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String)
                @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
                @publication = (x = opts.delete(:publication); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Publication) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Publication.apply(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                SubscriptionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :organization_key => organization_key,
                  :user_guid => user_guid,
                  :publication => publication.value
                }
              end

            end

            # A token gives a user access to the API.
            class Token

              attr_reader :guid, :user, :masked_token, :description, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @user = (x = opts.delete(:user); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::User) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x))
                @masked_token = HttpClient::Preconditions.assert_class('masked_token', opts.delete(:masked_token), String)
                @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Token.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :user => user.to_hash,
                  :masked_token => masked_token,
                  :description => description,
                  :audit => audit.to_hash
                }
              end

            end

            class TokenForm

              attr_reader :user_guid, :description

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
                @description = (x = opts.delete(:description); x.nil? ? nil : HttpClient::Preconditions.assert_class('description', x, String))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                TokenForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :user_guid => user_guid,
                  :description => description
                }
              end

            end

            # A user is a top level person interacting with the api doc server.
            class User

              attr_reader :guid, :email, :nickname, :name, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
                @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                User.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :email => email,
                  :nickname => nickname,
                  :name => name,
                  :audit => audit.to_hash
                }
              end

            end

            class UserForm

              attr_reader :email, :password, :nickname, :name

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                @password = HttpClient::Preconditions.assert_class('password', opts.delete(:password), String)
                @nickname = (x = opts.delete(:nickname); x.nil? ? nil : HttpClient::Preconditions.assert_class('nickname', x, String))
                @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                UserForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :email => email,
                  :password => password,
                  :nickname => nickname,
                  :name => name
                }
              end

            end

            # Summary of a user sufficient for display
            class UserSummary

              attr_reader :guid, :nickname

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                UserSummary.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :nickname => nickname
                }
              end

            end

            class UserUpdateForm

              attr_reader :email, :nickname, :name

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @email = HttpClient::Preconditions.assert_class('email', opts.delete(:email), String)
                @nickname = HttpClient::Preconditions.assert_class('nickname', opts.delete(:nickname), String)
                @name = (x = opts.delete(:name); x.nil? ? nil : HttpClient::Preconditions.assert_class('name', x, String))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                UserUpdateForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :email => email,
                  :nickname => nickname,
                  :name => name
                }
              end

            end

            # Used only to validate json files - used as a resource where http status code
            # defines success
            class Validation

              attr_reader :valid, :errors

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @valid = HttpClient::Preconditions.assert_boolean('valid', opts.delete(:valid))
                @errors = HttpClient::Preconditions.assert_class('errors', (x = opts.delete(:errors); x.nil? ? [] : x), Array).map { |v| HttpClient::Preconditions.assert_class('errors', v, String) }
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Validation.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :valid => valid,
                  :errors => errors
                }
              end

            end

            # Represents a unique version of the application.
            class Version

              attr_reader :guid, :organization, :application, :version, :original, :service, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @application = (x = opts.delete(:application); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Reference) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Reference.new(x))
                @version = HttpClient::Preconditions.assert_class('version', opts.delete(:version), String)
                @original = (x = opts.delete(:original); x.nil? ? nil : (x = x; x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Original) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Original.new(x)))
                @service = (x = opts.delete(:service); x.is_a?(::Com::Bryzek::Apidoc::Spec::V0::Models::Service) ? x : ::Com::Bryzek::Apidoc::Spec::V0::Models::Service.new(x))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Version.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :organization => organization.to_hash,
                  :application => application.to_hash,
                  :version => version,
                  :original => original.nil? ? nil : original.to_hash,
                  :service => service.to_hash,
                  :audit => audit.to_hash
                }
              end

            end

            class VersionForm

              attr_reader :original_form, :visibility

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @original_form = (x = opts.delete(:original_form); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::OriginalForm) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::OriginalForm.new(x))
                @visibility = (x = opts.delete(:visibility); x.nil? ? nil : (x = x; x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Visibility) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Visibility.apply(x)))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                VersionForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :original_form => original_form.to_hash,
                  :visibility => visibility.nil? ? nil : visibility.value
                }
              end

            end

            # Users can watch individual applications which enables features like receiving
            # an email notification when there is a new version of an application.
            class Watch

              attr_reader :guid, :user, :organization, :application, :audit

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @guid = HttpClient::Preconditions.assert_class('guid', HttpClient::Helper.to_uuid(opts.delete(:guid)), String)
                @user = (x = opts.delete(:user); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::User) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::User.new(x))
                @organization = (x = opts.delete(:organization); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Organization) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Organization.new(x))
                @application = (x = opts.delete(:application); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Application) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Application.new(x))
                @audit = (x = opts.delete(:audit); x.is_a?(::Com::Bryzek::Apidoc::Api::V0::Models::Audit) ? x : ::Com::Bryzek::Apidoc::Api::V0::Models::Audit.new(x))
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                Watch.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :guid => guid,
                  :user => user.to_hash,
                  :organization => organization.to_hash,
                  :application => application.to_hash,
                  :audit => audit.to_hash
                }
              end

            end

            class WatchForm

              attr_reader :user_guid, :organization_key, :application_key

              def initialize(incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @user_guid = HttpClient::Preconditions.assert_class('user_guid', HttpClient::Helper.to_uuid(opts.delete(:user_guid)), String)
                @organization_key = HttpClient::Preconditions.assert_class('organization_key', opts.delete(:organization_key), String)
                @application_key = HttpClient::Preconditions.assert_class('application_key', opts.delete(:application_key), String)
              end

              def to_json
                JSON.dump(to_hash)
              end

              def copy(incoming={})
                WatchForm.new(to_hash.merge(HttpClient::Helper.symbolize_keys(incoming)))
              end

              def to_hash
                {
                  :user_guid => user_guid,
                  :organization_key => organization_key,
                  :application_key => application_key
                }
              end

            end

          end

          # ===== END OF SERVICE DEFINITION =====
          module HttpClient

            class Request

              def initialize(uri)
                @uri = Preconditions.assert_class('uri', uri, URI)
                @params = nil
                @body = nil
                @auth = nil
                @headers = {}
                @header_keys_lower_case = []
              end

              def with_header(name, value)
                Preconditions.check_not_blank('name', name, "Header name is required")
                Preconditions.check_not_blank('value', value, "Header value is required")
                Preconditions.check_state(!@headers.has_key?(name),
                                          "Duplicate header named[%s]" % name)
                @headers[name] = value
                @header_keys_lower_case << name.downcase
                self
              end

              def with_auth(auth)
                Preconditions.assert_class('auth', auth, HttpClient::Authorization)
                Preconditions.check_state(@auth.nil?, "auth previously set")

                if auth.scheme.name == AuthScheme::BASIC.name
                  @auth = auth
                else
                  raise "Auth Scheme[#{auth.scheme.name}] not supported"
                end
                self
              end

              def with_query(params)
                Preconditions.assert_class('params', params, Hash)
                Preconditions.check_state(@params.nil?, "Already have query parameters")
                @params = params
                self
              end

              # Wrapper to set Content-Type header to application/json and set
              # the provided json document as the body
              def with_json(json)
                @headers['Content-Type'] ||= 'application/json; charset=UTF-8'
                with_body(json)
              end

              def with_body(body)
                Preconditions.check_not_blank('body', body)
                @body = body
                self
              end

              # Creates a new Net:HTTP client. The client returned should be
              # fully configured to make a request.
              def new_http_client
                client = Net::HTTP.new(@uri.host, @uri.port)
                if @uri.scheme == "https"
                  configure_ssl(client)
                end
                client
              end

              # If HTTP is required, this method accepts an HTTP Client and configures SSL
              def configure_ssl(client)
                Preconditions.assert_class('client', client, Net::HTTP)
                client.use_ssl = true
                client.verify_mode = OpenSSL::SSL::VERIFY_PEER
                client.cert_store = OpenSSL::X509::Store.new
                client.cert_store.set_default_paths
              end

              def get(&block)
                do_request(Net::HTTP::Get, &block)
              end

              def delete(&block)
                do_request(Net::HTTP::Delete, &block)
              end

              def options(&block)
                do_request(Net::HTTP::Options, &block)
              end

              def post(&block)
                do_request(Net::HTTP::Post, &block)
              end

              def put(&block)
                do_request(Net::HTTP::Put, &block)
              end

              class PATCH < Net::HTTP::Put
                METHOD = "PATCH"
              end

              def patch(&block)
                do_request(PATCH, &block)
              end

              def do_request(klass)
                Preconditions.assert_class('klass', klass, Class)

                uri = @uri.to_s
                if q = to_query(@params)
                  uri += "?%s" % q
                end

                request = klass.send(:new, uri)

                curl = ['curl']
                if klass != Net::HTTP::Get
                  curl << "-X%s" % klass.name.split("::").last.upcase
                end

                if @body
                  # DEBUG path = "/tmp/rest_client.tmp"
                  # DEBUG File.open(path, "w") { |os| os << @body.to_s }
                  # DEBUG curl << "-d@%s" % path
                  request.body = @body
                end

                if @auth
                  curl << "-u \"%s:%s\"" % [@auth.username, @auth.password]
                  Preconditions.check_state(!@header_keys_lower_case.include?("authorization"),
                                            "Cannot specify both an Authorization header and an auth instance")
                  user_pass = "%s:%s" % [@auth.username, @auth.password]
                  encoded = Base64.encode64(user_pass).to_s.split("\n").map(&:strip).join
                  request.add_field("Authorization", "Basic %s" % encoded)
                end

                @headers.each { |key, value|
                  curl <<  "-H \"%s: %s\"" % [key, value]
                  request.add_field(key, value)
                }

                curl << "'%s'" % uri
                # DEBUG puts curl.join(" ")

                raw_response = http_request(request)
                response = raw_response.to_s == "" ? nil : JSON.parse(raw_response)

                if block_given?
                  yield response
                else
                  response
                end
              end

              private
              def to_query(params={})
                parts = (params || {}).map { |k,v|
                  if v.respond_to?(:each)
                    v.map { |el| "%s=%s" % [k, CGI.escape(el.to_s)] }
                  else
                    "%s=%s" % [k, CGI.escape(v.to_s)]
                  end
                }
                parts.empty? ? nil : parts.join("&")
              end

              def http_request(request)
                response = begin
                             new_http_client.request(request)
                           rescue SocketError => e
                             raise Exception.new("Error accessing uri[#{@uri}]: #{e}")
                           end

                case response
                when Net::HTTPSuccess
                  response.body
                else
                  body = response.body rescue nil
                  raise HttpClient::ServerError.new(response.code.to_i, response.message, :body => body, :uri => @uri.to_s)
                end
              end
            end

            class ServerError < StandardError

              attr_reader :code, :details, :body, :uri

              def initialize(code, details, incoming={})
                opts = HttpClient::Helper.symbolize_keys(incoming)
                @code = HttpClient::Preconditions.assert_class('code', code, Integer)
                @details = HttpClient::Preconditions.assert_class('details', details, String)
                @body = HttpClient::Preconditions.assert_class_or_nil('body', opts.delete(:body), String)
                @uri = HttpClient::Preconditions.assert_class_or_nil('uri', opts.delete(:uri), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
                super(self.message)
              end

              def message
                m = "%s %s" % [@code, @details]
                if @body
                  m << ": %s" % @body
                end
                m
              end

              def body_json
                JSON.parse(@body)
              end

            end

            module Preconditions

              def Preconditions.check_argument(expression, error_message=nil)
                if !expression
                  raise error_message || "check_argument failed"
                end
                nil
              end

              def Preconditions.check_state(expression, error_message=nil)
                if !expression
                  raise error_message || "check_state failed"
                end
                nil
              end

              def Preconditions.check_not_nil(field_name, reference, error_message=nil)
                if reference.nil?
                  raise error_message || "argument for %s cannot be nil" % field_name
                end
                reference
              end

              def Preconditions.check_not_blank(field_name, reference, error_message=nil)
                if reference.to_s.strip == ""
                  raise error_message || "argument for %s cannot be blank" % field_name
                end
                reference
              end

              # Throws an error if opts is not empty. Useful when parsing
              # arguments to a function
              def Preconditions.assert_empty_opts(opts)
                if !opts.empty?
                  raise "Invalid opts: #{opts.keys.inspect}\n#{opts.inspect}"
                end
              end

              # Asserts that value is not nill and is_?(klass). Returns
              # value. Common use is
              #
              # amount = Preconditions.assert_class('amount', amount, BigDecimal)
              def Preconditions.assert_class(field_name, value, klass)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('klass', klass)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of class %s" % [field_name, klass.name])
                Preconditions.check_state(value.is_a?(klass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[#{klass}] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_class_or_nil(field_name, value, klass)
                if !value.nil?
                  Preconditions.assert_class(field_name, value, klass)
                end
              end

              def Preconditions.assert_boolean(field_name, value)
                Preconditions.check_not_nil('field_name', field_name)
                Preconditions.check_not_nil('value', value, "Value for %s cannot be nil. Expected an instance of TrueClass or FalseClass" % field_name)
                Preconditions.check_state(value.is_a?(TrueClass) || value.is_a?(FalseClass),
                                          "Value for #{field_name} is of type[#{value.class}] - class[TrueClass or FalseClass] is required. value[#{value.inspect.to_s}]")
                value
              end

              def Preconditions.assert_boolean_or_nil(field_name, value)
                if !value.nil?
                  Preconditions.assert_boolean(field_name, value)
                end
              end

              def Preconditions.assert_collection_of_class(field_name, values, klass)
                Preconditions.assert_class(field_name, values, Array)
                values.each { |v| Preconditions.assert_class(field_name, v, klass) }
              end

              def Preconditions.assert_hash_of_class(field_name, hash, klass)
                Preconditions.assert_class(field_name, hash, Hash)
                values.each { |k, v| Preconditions.assert_class(field_name, v, klass) }
              end

            end

            class AuthScheme

              attr_reader :name

              def initialize(name)
                @name = HttpClient::Preconditions.check_not_blank('name', name)
              end

              BASIC = AuthScheme.new("basic") unless defined?(BASIC)

            end

            class Authorization

              attr_reader :scheme, :username, :password

              def initialize(scheme, username, opts={})
                @scheme = HttpClient::Preconditions.assert_class('schema', scheme, AuthScheme)
                @username = HttpClient::Preconditions.check_not_blank('username', username, "username is required")
                @password = HttpClient::Preconditions.assert_class_or_nil('password', opts.delete(:password), String)
                HttpClient::Preconditions.assert_empty_opts(opts)
              end

              def Authorization.basic(username, password=nil)
                Authorization.new(AuthScheme::BASIC, username, :password => password)
              end

            end

            module Helper

              def Helper.symbolize_keys(hash)
                Preconditions.assert_class('hash', hash, Hash)
                new_hash = {}
                hash.each { |k, v|
                  new_hash[k.to_sym] = v
                }
                new_hash
              end

              def Helper.to_big_decimal(value)
                value ? BigDecimal.new(value.to_s) : nil
              end

              def Helper.to_object(value)
                value ? JSON.parse(value) : nil
              end

              def Helper.to_uuid(value)
                Preconditions.check_state(value.nil? || value.match(/^\w\w\w\w\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\-\w\w\w\w\w\w\w\w\w\w\w\w$/),
                                          "Invalid guid[%s]" % value)
                value
              end

              def Helper.to_date_iso8601(value)
                if value.is_a?(Date)
                  value
                elsif value
                  Date.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.to_date_time_iso8601(value)
                if value.is_a?(DateTime)
                  value
                elsif value
                  DateTime.parse(value.to_s)
                else
                  nil
                end
              end

              def Helper.date_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%d')
              end

              def Helper.date_time_iso8601_to_string(value)
                value.nil? ? nil : value.strftime('%Y-%m-%dT%H:%M:%S%z')
              end

              TRUE_STRINGS = ['t', 'true', 'y', 'yes', 'on', '1', 'trueclass'] unless defined?(TRUE_STRINGS)
              FALSE_STRINGS = ['f', 'false', 'n', 'no', 'off', '0', 'falseclass'] unless defined?(FALSE_STRINGS)

              def Helper.to_boolean(field_name, value)
                string = value.to_s.strip.downcase
                if TRUE_STRINGS.include?(string)
                  true
                elsif FALSE_STRINGS.include?(string)
                  false
                elsif string != ""
                  raise "Unsupported boolean value[#{string}]. For true, must be one of: #{TRUE_STRINGS.inspect}. For false, must be one of: #{FALSE_STRINGS.inspect}"
                else
                  nil
                end
              end

            end

          end
        end
      end
    end
  end
end